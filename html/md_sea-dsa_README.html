<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SeaDsa: A Points-to Analysis for Verification of Low-level C/C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SeaDsa: A Points-to Analysis for Verification of Low-level C/C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/seahorn/sea-dsa"><object type="image/svg+xml" data="https://travis-ci.org/seahorn/sea-dsa.svg?branch=master" style="pointer-events: none;" title="Ubuntu 14.04 LTS 64bit, g++-5"></object> </a></p>
<p><code>SeaDsa</code> is a context-, field-, and array-sensitive unification-based points-to analysis for LLVM bitcode inspired by <a href="http://llvm.org/pubs/2003-11-15-DataStructureAnalysisTR.ps">DSA</a>. <code>SeaDsa</code> is an order of magnitude more scalable and precise than <code>Dsa</code> and a previous implementation of <code>SeaDsa</code> thanks to improved handling of context sensitivity, addition of partial flow-sensitivity, and type-awareness. <br  />
</p>
<p>Although <code>SeaDsa</code> can analyze arbitrary LLVM bitcode, it has been tailored for use in program verification of C/C++ programs. It can be used as a stand-alone tool or together with the <a href="https://github.com/seahorn/seahorn">SeaHorn</a> verification framework and its analyses.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Requirements</h1>
<p><code>SeaDsa</code> is written in C++ and uses the Boost library. The main requirements are:</p>
<ul>
<li>C++ compiler supporting c++14</li>
<li>Boost &gt;= 1.65</li>
<li>LLVM 10</li>
</ul>
<p>To run tests, install the following packages:</p>
<ul>
<li><code>sudo pip install lit OutputCheck</code></li>
<li><code>sudo easy_install networkx</code></li>
<li><code>sudo apt-get install libgraphviz-dev</code></li>
<li><code>sudo easy_install pygraphviz</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md53"></a>
Project Structure</h1>
<ol type="1">
<li>The main Points-To Graph data structures, <code>Graph</code>, <code>Cell</code>, and <code>Node</code>, are defined in <code>include/Graph.hh</code> and <code>src/Graph.cc</code>.</li>
<li>The <em>Local</em> analysis is in <code>include/Local.hh</code> and <code>src/DsaLocal.cc</code>.</li>
<li>The <em>Bottom-Up</em> analysis is in <code>include/BottomUp.hh</code> and <code>src/DsaBottomUp.cc</code>.</li>
<li>The <em>Top-Down</em> analysis is in <code>include/TopDown.hh</code> and <code>src/DsaTopDown.cc</code>.</li>
<li>The interprocedural node cloner is in <code>include/Cloner.hh</code> and <code>src/Clonner.cc</code>.</li>
<li>Type handling code is in <code>include/FieldType.hh</code>, <code>include/TypeUtils.hh</code>, <code>src/FieldType.cc</code>, and <code>src/TypeUtils.cc</code>.</li>
<li>The allocator function discovery is in <code>include/AllocWrapInfo.hh</code> and <code>src/AllocWrapInfo.cc</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md54"></a>
Compilation and Usage</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
Program Verification benchmarks</h2>
<p>Instructions on running program verification benchmarks, together with recipes for building real-world projects and our results, can be found in <a href="https://github.com/kuhar/tea-dsa-extras">tea-dsa-extras</a>.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Integration in other C++ projects (for users)</h2>
<p><code>SeaDsa</code> contains two directories: <code>include</code> and <code>src</code>. Since <code>SeaDsa</code> analyzes LLVM bitcode, LLVM header files and libraries must be accessible when building with <code>SeaDsa</code>.</p>
<p>If your project uses <code>cmake</code> then you just need to add in your project's <code>CMakeLists.txt</code>: </p><pre class="fragment"> include_directories(seadsa/include)
 add_subdirectory(seadsa)
</pre><h2><a class="anchor" id="autotoc_md57"></a>
Standalone (for developers)</h2>
<p>If you already installed <code>llvm-10</code> on your machine: </p><pre class="fragment">mkdir build &amp;&amp; cd build
cmake -DCMAKE_INSTALL_PREFIX=run -DLLVM_DIR=__here_llvm-10__/share/llvm/cmake  ..
cmake --build . --target install
</pre><p>Otherwise: </p><pre class="fragment">mkdir build &amp;&amp; cd build
cmake -DCMAKE_INSTALL_PREFIX=run ..
cmake --build . --target install
</pre><p>To run tests: </p><pre class="fragment">cmake --build . --target test-sea-dsa
</pre><h1><a class="anchor" id="autotoc_md58"></a>
Visualizing Memory Graphs and Complete Call Graphs</h1>
<p>Consider a C program called <code>tests/c/simple.c</code>:</p>
<div class="fragment"><div class="line">#include &lt;stdlib.h&gt;</div>
<div class="line"> </div>
<div class="line">typedef struct S {</div>
<div class="line">  int** x;</div>
<div class="line">  int** y;  </div>
<div class="line">} S;</div>
<div class="line"> </div>
<div class="line">int g;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv){</div>
<div class="line"> </div>
<div class="line">  S s1, s2;</div>
<div class="line"> </div>
<div class="line">  int* p1 = (int*) malloc(sizeof(int));</div>
<div class="line">  int* q1 = (int*) malloc(sizeof(int));  </div>
<div class="line">  s1.x = &amp;p1;</div>
<div class="line">  s1.y = &amp;q1;    </div>
<div class="line">  *(s1.x) = &amp;g;</div>
<div class="line">  </div>
<div class="line">  return 0;</div>
<div class="line">}   </div>
</div><!-- fragment --><ol type="1">
<li>Generate bitcode: <pre class="fragment"> clang -O0 -c -emit-llvm -S tests/c/simple.c -o simple.ll
</pre></li>
</ol>
<p>The option <code>-O0</code> is used to disable clang optimizations. In general, it is a good idea to enable clang optimizations. However, for trivial examples like <code>simple.c</code>, clang simplifies too much so nothing useful would be observed. The options <code>-c -emit-llvm -<a class="el" href="structS.html">S</a></code> generate bitcode in human-readable format.</p>
<ol type="1">
<li>Run <code>sea-dsa</code> on the bitcode and print memory graphs to <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">dot</a> format: <pre class="fragment"> seadsa -sea-dsa=butd-cs -sea-dsa-type-aware -sea-dsa-dot  simple.ll
</pre></li>
</ol>
<p>The options <code>-sea-dsa=butd-cs -sea-dsa-type-aware</code> enable the analysis implemented in our FMCAD'19 paper (see References). This command will generate a <code>FUN.mem.dot</code> file for each function <code>FUN</code> in the bitcode program. In our case, the only function is <code>main</code> and thus, there is one file named <code>main.mem.dot</code>. The file is generated in the current directory. If you want to store the <code>.dot</code> files in a different directory <code>DIR</code> then add the option <code>-sea-dsa-dot-outdir=DIR</code></p>
<ol type="1">
<li>Visualize <code>main.mem.dot</code> by transforming it to a <code>pdf</code> file: <pre class="fragment"> dot -Tpdf main.mem.dot -o main.mem.pdf
 open main.mem.pdf  // replace with you favorite pdf viewer 
</pre></li>
</ol>
<p><img src="https://github.com/seahorn/sea-dsa/blob/tea-dsa/tests/expected_graphs/simple.jpg?raw=true" alt="Example of a memory graph" class="inline"/></p>
<p>In our memory model, a pointer is represented by a <b>cell</b> which is a pair of a memory object and offset. Memory objects are represented as nodes in the memory graph. Edges are between cells.</p>
<p>Each node field represents a cell (i.e., an offset in the node). For instance, the node fields <code>&lt;0,i32**&gt;</code> and <code>&lt;8,i32**&gt;</code> pointed by <code>%6</code> and <code>%15</code>, respectively are two different cells from the same memory object. The field <code>&lt;8,i32**&gt;</code> represents the cell at offset 8 in the corresponding memory object and its type is <code>i32**</code>. Since edges are between cells, they are labeled with a number that represents the offset in the destination node. Blue edges connect formal parameters of the function with a cell. Purple edges connect LLVM pointer variables with cells. Nodes can have markers such as <code><a class="el" href="structS.html">S</a></code> (stack allocated memory), <code>H</code> (heap allocate memory), <code>M</code> (modified memory), <code>R</code> (read memory), <code>E</code> (externally allocated memory), etc. If a node is red then it means that the analysis lost field sensitivity for that node. The label <code>{void}</code> is used to denote that the node has been allocated but it has not been used by the program.</p>
<p><code>sea-dsa</code> can also resolve indirect calls. An <em>indirect call</em> is a call where the callee is not known statically. <code>sea-dsa</code> identifies all possible callees of an indirect call and generates a LLVM call graph as output.</p>
<p>Consider this example in <code>tests/c/complete_callgraph_5.c</code>:</p>
<div class="fragment"><div class="line">struct class_t;</div>
<div class="line">typedef int (*FN_PTR)(struct class_t *, int);</div>
<div class="line">typedef struct class_t {</div>
<div class="line">  FN_PTR m_foo;</div>
<div class="line">  FN_PTR m_bar;</div>
<div class="line">} class_t;</div>
<div class="line"> </div>
<div class="line">int foo(class_t *self, int x)</div>
<div class="line">{</div>
<div class="line">  if (x &gt; 10) {</div>
<div class="line">    return self-&gt;m_bar(self, x + 1);</div>
<div class="line">  } else</div>
<div class="line">    return x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int bar (class_t *self, int y) {</div>
<div class="line">  if (y &lt; 100) {</div>
<div class="line">    return y + self-&gt;m_foo(self, 10);</div>
<div class="line">  } else</div>
<div class="line">    return y - 5;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  class_t obj;</div>
<div class="line">  obj.m_foo = &amp;foo;</div>
<div class="line">  obj.m_bar = &amp;bar;</div>
<div class="line">  int res;</div>
<div class="line">  res = obj.m_foo(&amp;obj, 42);</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Type the commands: </p><pre class="fragment">clang -c -emit-llvm -S tests/c/complete_callgraph_5.c  -o ex.ll
sea-dsa --sea-dsa-callgraph-dot ex.ll
</pre><p>It generates a <code>.dot</code> file called <code>callgraph.dot</code> in the current directory. Again, the <code>.dot</code> file can be converted to a <code>.pdf</code> file and opened with the commands: </p><pre class="fragment">dot -Tpdf callgraph.dot -o callgraph.pdf
open callgraph.pdf  
</pre><p><img src="https://github.com/seahorn/sea-dsa/blob/tea-dsa/tests/expected_graphs/complete_callgraph_5.jpg?raw=true" alt="Example of a call graph" class="inline"/></p>
<p><code>sea-dsa</code> can also print some statistics about the call graph resolution process (note that you need to call <code>clang</code> with <code>-g</code> to print file,line, and column information): </p><pre class="fragment">sea-dsa --sea-dsa-callgraph-stats ex.ll


=== Sea-Dsa CallGraph Statistics === 
** Total number of indirect calls 0
** Total number of resolved indirect calls 3

%16 = call i32 %12(%struct.class_t* %13, i32 %15) at tests/c/complete_callgraph_5.c:14:12
RESOLVED
Callees:
  i32 bar(%struct.class_t*,i32)

%15 = call i32 %13(%struct.class_t* %14, i32 10) at tests/c/complete_callgraph_5.c:23:16
RESOLVED
Callees:
  i32 foo(%struct.class_t*,i32)

%11 = call i32 %10(%struct.class_t* %2, i32 42) at tests/c/complete_callgraph_5.c:36:9
RESOLVED
Callees:
  i32 foo(%struct.class_t*,i32)
</pre><h1><a class="anchor" id="autotoc_md59"></a>
Dealing with C/C++ library and external calls</h1>
<p>The pointer semantics of external calls can be defined by writing a wrapper that calls any of these functions defined in <code>seadsa/seadsa.h</code>:</p>
<ul>
<li><code>extern void seadsa_alias(const void *p, ...);</code></li>
<li><code>extern void seadsa_collapse(const void *p);</code></li>
<li><code>extern void seadsa_mk_seq(const void *p, unsigned sz);</code></li>
</ul>
<p><code>seadsa_alias</code> unifies all argument's cells, <code>seadsa_collapse</code> tells <code>sea-dsa</code> to collapse (i.e., loss of field-sensitivity) the cell pointed by <code>p</code>, and <code>seadsa_mk_seq</code> tells <code>sea-dsa</code> to mark as <em>sequence</em> the node pointed by <code>p</code> with size <code>sz</code>.</p>
<p>For instance, consider an external call <code>foo</code> defined as follows: </p><pre class="fragment">extern void* foo(const void*p1, void *p2, void *p3);
</pre><p>Suppose that the returned pointer should be unified to <code>p2</code> but not to <code>p1</code>. In addition, we would like to collapse the cell corresponding to <code>p3</code>. Then, we can replace the above prototype of <code>foo</code> with the following definition: </p><pre class="fragment">#include "seadsa/seadsa.h"
void* foo(const void*p1, void *p2, void*p3) {
    void* r = seadsa_new();
    seadsa_alias(r,p2);
    seadsa_collapse(p3);
    return r;
}
</pre><h1><a class="anchor" id="autotoc_md60"></a>
References</h1>
<ol type="1">
<li>"A Context-Sensitive Memory Model for Verification of C/C++
   Programs" by A. Gurfinkel and J. A. Navas. In SAS'17. (<a href="https://jorgenavas.github.io/papers/sea-dsa-SAS17.pdf">Paper</a>) | (<a href="https://jorgenavas.github.io/slides/sea-dsa-SAS17-slides.pdf">Slides</a>)</li>
<li>"Unification-based Pointer Analysis without Oversharing" by J. Kuderski, J. A. Navas and A. Gurfinkel. In FMCAD'19. (<a href="https://jorgenavas.github.io/papers/tea-dsa-fmcad19.pdf">Paper</a>) </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
