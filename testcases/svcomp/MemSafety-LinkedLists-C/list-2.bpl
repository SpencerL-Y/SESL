// generated by SMACK version 2.6.3 for corral
// via /usr/local/bin/smack ../svcomp/MemSafety-LinkedLists-C//list-2.c -ll ../svcomp/MemSafety-LinkedLists-C//list-2_IR.ll --bpl ../svcomp/MemSafety-LinkedLists-C//list-2.bpl -t --sh-mem-leak

const reach_error: ref;
axiom (reach_error == $sub.ref(0, 1032));
procedure  reach_error()
{
$bb0:
  return;
}
const myexit: ref;
axiom (myexit == $sub.ref(0, 2064));
procedure  myexit($i0: i32)
{
$bb0:
  call {:cexpr "myexit:arg:s"} boogie_si_record_i32($i0);
  goto $bb1;
$bb1:
  assume true;
  goto $bb1;
}
const llvm.dbg.declare: ref;
axiom (llvm.dbg.declare == $sub.ref(0, 3096));
procedure  llvm.dbg.declare($p0: ref, $p1: ref, $p2: ref);
const llvm.dbg.label: ref;
axiom (llvm.dbg.label == $sub.ref(0, 4128));
procedure  llvm.dbg.label($p0: ref);
const main: ref;
axiom (main == $sub.ref(0, 5160));
procedure {:entrypoint} main()
  returns ($r: i32)
{
  var $p0: ref8;
  var $p1: ref;
  var $i2: i1;
  var $i3: i32;
  var $i4: i1;
  var $p6: ref;
  var $p7: ref32;
  var $p8: ref8;
  var $p9: ref;
  var $i10: i1;
  var $p11: ref;
  var $p12: ref;
  var $p13: ref;
  var $i14: i32;
  var $i15: i1;
  var $p16: ref;
  var $p5: ref;
  var $i17: i32;
  var $i18: i1;
  var $p20: ref;
  var $p21: ref32;
  var $p22: ref8;
  var $p23: ref;
  var $i24: i1;
  var $p25: ref;
  var $p26: ref;
  var $p27: ref;
  var $i28: i32;
  var $i29: i1;
  var $p30: ref;
  var $p19: ref;
  var $p31: ref32;
  var $p32: ref32;
  var $i33: i32;
  var $i34: i1;
  var $p36: ref;
  var $p37: ref;
  var $p38: ref;
  var $p39: ref32;
  var $i40: i32;
  var $i41: i1;
  var $p42: ref;
  var $p35: ref;
  var $p43: ref32;
  var $i44: i32;
  var $i45: i1;
  var $p47: ref;
  var $p48: ref;
  var $p49: ref;
  var $p50: ref32;
  var $i51: i32;
  var $i52: i1;
  var $p53: ref;
  var $p46: ref;
  var $p54: ref32;
  var $i55: i32;
  var $i56: i1;
$bb0:
  call {:cexpr "smack:entry:main"} boogie_si_record_ref(main);
  call $p0 := malloc(16);
  $p1 := $bitcast.ref.ref($p0);
  $i2 := $eq.ref($p1, $0.ref);
  assume {:branchcond $i2} true;
  goto $bb1, $bb2;
$bb1:
  assume ($i2 == 1);
  call myexit(1);
  goto $bb3;
$bb2:
  assume !(($i2 == 1));
  goto $bb3;
$bb3:
  call $i3 := __VERIFIER_nondet_int();
  call {:cexpr "smack:ext:__VERIFIER_nondet_int"} boogie_si_record_i32($i3);
  $i4 := $ne.i32($i3, 0);
  $p5 := $p0;
  assume {:branchcond $i4} true;
  goto $bb4, $bb5;
$bb4:
  assume ($i4 == 1);
  $p6 := $p0;
  goto $bb7;
$bb5:
  assume !(($i4 == 1));
  goto $bb6;
$bb6:
  call $i17 := __VERIFIER_nondet_int();
  call {:cexpr "smack:ext:__VERIFIER_nondet_int"} boogie_si_record_i32($i17);
  $i18 := $ne.i32($i17, 0);
  $p19 := $p5;
  assume {:branchcond $i18} true;
  goto $bb13, $bb14;
$bb7:
  $p7 := $add.ref($add.ref($p6, $mul.ref(0, 16)), $mul.ref(0, 1));
  $M.0 := $store.i32($M.0, $p7, 1);
  call $p8 := malloc(16);
  $p9 := $bitcast.ref.ref($p8);
  $i10 := $eq.ref($p9, $0.ref);
  assume {:branchcond $i10} true;
  goto $bb8, $bb9;
$bb8:
  assume ($i10 == 1);
  call myexit(1);
  goto $bb10;
$bb9:
  assume !(($i10 == 1));
  goto $bb10;
$bb10:
  $p11 := $add.ref($add.ref($p6, $mul.ref(0, 16)), $mul.ref(8, 1));
  $M.1 := $store.ref($M.1, $p11, $p8);
  $p12 := $add.ref($add.ref($p6, $mul.ref(0, 16)), $mul.ref(8, 1));
  $p13 := $load.ref($M.1, $p12);
  call $i14 := __VERIFIER_nondet_int();
  call {:cexpr "smack:ext:__VERIFIER_nondet_int"} boogie_si_record_i32($i14);
  $i15 := $ne.i32($i14, 0);
  $p16 := $p13;
  assume {:branchcond $i15} true;
  goto $bb11, $bb12;
$bb11:
  assume ($i15 == 1);
  $p6 := $p13;
  goto $bb7;
$bb12:
  assume !(($i15 == 1));
  $p5 := $p16;
  goto $bb6;
$bb13:
  assume ($i18 == 1);
  $p20 := $p5;
  goto $bb16;
$bb14:
  assume !(($i18 == 1));
  goto $bb15;
$bb15:
  $p31 := $add.ref($add.ref($p19, $mul.ref(0, 16)), $mul.ref(0, 1));
  $M.0 := $store.i32($M.0, $p31, 3);
  $p32 := $add.ref($add.ref($p1, $mul.ref(0, 16)), $mul.ref(0, 1));
  $i33 := $load.i32($M.0, $p32);
  $i34 := $eq.i32($i33, 2);
  $p35 := $p0;
  assume {:branchcond $i34} true;
  goto $bb22, $bb23;
$bb16:
  $p21 := $add.ref($add.ref($p20, $mul.ref(0, 16)), $mul.ref(0, 1));
  $M.0 := $store.i32($M.0, $p21, 2);
  call $p22 := malloc(16);
  $p23 := $bitcast.ref.ref($p22);
  $i24 := $eq.ref($p23, $0.ref);
  assume {:branchcond $i24} true;
  goto $bb17, $bb18;
$bb17:
  assume ($i24 == 1);
  call myexit(1);
  goto $bb19;
$bb18:
  assume !(($i24 == 1));
  goto $bb19;
$bb19:
  $p25 := $add.ref($add.ref($p20, $mul.ref(0, 16)), $mul.ref(8, 1));
  $M.1 := $store.ref($M.1, $p25, $p22);
  $p26 := $add.ref($add.ref($p20, $mul.ref(0, 16)), $mul.ref(8, 1));
  $p27 := $load.ref($M.1, $p26);
  call $i28 := __VERIFIER_nondet_int();
  call {:cexpr "smack:ext:__VERIFIER_nondet_int"} boogie_si_record_i32($i28);
  $i29 := $ne.i32($i28, 0);
  $p30 := $p27;
  assume {:branchcond $i29} true;
  goto $bb20, $bb21;
$bb20:
  assume ($i29 == 1);
  $p20 := $p27;
  goto $bb16;
$bb21:
  assume !(($i29 == 1));
  $p19 := $p30;
  goto $bb15;
$bb22:
  assume ($i34 == 1);
  $p36 := $p0;
  goto $bb25;
$bb23:
  assume !(($i34 == 1));
  goto $bb24;
$bb24:
  $p43 := $add.ref($add.ref($p35, $mul.ref(0, 16)), $mul.ref(0, 1));
  $i44 := $load.i32($M.0, $p43);
  $i45 := $eq.i32($i44, 1);
  $p46 := $p35;
  assume {:branchcond $i45} true;
  goto $bb28, $bb29;
$bb25:
  $p37 := $add.ref($add.ref($p36, $mul.ref(0, 16)), $mul.ref(8, 1));
  $p38 := $load.ref($M.1, $p37);
  $p39 := $add.ref($add.ref($p38, $mul.ref(0, 16)), $mul.ref(0, 1));
  $i40 := $load.i32($M.0, $p39);
  $i41 := $eq.i32($i40, 2);
  $p42 := $p38;
  assume {:branchcond $i41} true;
  goto $bb26, $bb27;
$bb26:
  assume ($i41 == 1);
  $p36 := $p38;
  goto $bb25;
$bb27:
  assume !(($i41 == 1));
  $p35 := $p42;
  goto $bb24;
$bb28:
  assume ($i45 == 1);
  $p47 := $p35;
  goto $bb31;
$bb29:
  assume !(($i45 == 1));
  goto $bb30;
$bb30:
  $p54 := $add.ref($add.ref($p46, $mul.ref(0, 16)), $mul.ref(0, 1));
  $i55 := $load.i32($M.0, $p54);
  $i56 := $ne.i32($i55, 3);
  assume {:branchcond $i56} true;
  goto $bb34, $bb35;
$bb31:
  $p48 := $add.ref($add.ref($p47, $mul.ref(0, 16)), $mul.ref(8, 1));
  $p49 := $load.ref($M.1, $p48);
  $p50 := $add.ref($add.ref($p49, $mul.ref(0, 16)), $mul.ref(0, 1));
  $i51 := $load.i32($M.0, $p50);
  $i52 := $eq.i32($i51, 1);
  $p53 := $p49;
  assume {:branchcond $i52} true;
  goto $bb32, $bb33;
$bb32:
  assume ($i52 == 1);
  $p47 := $p49;
  goto $bb31;
$bb33:
  assume !(($i52 == 1));
  $p46 := $p53;
  goto $bb30;
$bb34:
  assume ($i56 == 1);
  goto $bb36;
$bb35:
  assume !(($i56 == 1));
  $r := 0;
  return;
$bb36:
  assume true;
  call reach_error();
  call abort();
  assume false;
}
const malloc: ref;
axiom (malloc == $sub.ref(0, 6192));
procedure  malloc($i0: i64)
  returns ($r: ref)
{
  call $r := $malloc($i0);
}
const __VERIFIER_nondet_int: ref;
axiom (__VERIFIER_nondet_int == $sub.ref(0, 7224));
procedure  __VERIFIER_nondet_int()
  returns ($r: i32);
const abort: ref;
axiom (abort == $sub.ref(0, 8256));
procedure  abort();
const llvm.dbg.value: ref;
axiom (llvm.dbg.value == $sub.ref(0, 9288));
procedure  llvm.dbg.value($p0: ref, $p1: ref, $p2: ref);
const __SMACK_static_init: ref;
axiom (__SMACK_static_init == $sub.ref(0, 10320));
procedure  __SMACK_static_init()
{
$bb0:
  return;
}
procedure  boogie_si_record_i32(x: i32);
procedure  boogie_si_record_ref(x: ref);
procedure  $initialize()
{
  call __SMACK_static_init();
  return;
}
