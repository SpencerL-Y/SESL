SMACK program verifier version 2.6.3
Running clang -c -emit-llvm -O0 -g -gcolumn-info -Xclang -disable-O0-optnone -I/usr/local/share/smack/include -DMEMORY_MODEL_NO_REUSE_IMPLS -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-1-n22t044c.bc ../svcomp/memsafety//global-atexit-1.c
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-65h3nnd3.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-1-n22t044c.bc
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-go85jubk.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-65h3nnd3.bc
Running llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-go85jubk.bc -bpl ../svcomp/memsafety//global-atexit-1.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-1_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak
[regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: _Exit
 -------INSERT: Global Variables _Exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: _Exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 -----------------START MEMSAFE ANALYSIS---------------
 Begin verifying
 Adding procedure: free_g1
 Empty block name founded in proc free_g1
 Adding procedure: free_
 Empty block name founded in proc free_
 Adding procedure: free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Adding procedure: h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Adding procedure: __VERIFIER_nondet_bool
 Empty blocks of proc __VERIFIER_nondet_bool
 Adding procedure: _Exit
 Empty blocks of proc _Exit
 Adding procedure: f
 Empty block name founded in proc f
 Adding procedure: malloc
 Empty block name founded in proc malloc
 Adding procedure: atexit
 Empty blocks of proc atexit
 Adding procedure: main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Adding procedure: exit
 Empty blocks of proc exit
 Adding procedure: __SMACK_static_init
 Empty block name founded in proc __SMACK_static_init
 Adding procedure: boogie_si_record_i1
 Empty blocks of proc boogie_si_record_i1
 Adding procedure: boogie_si_record_ref
 Empty blocks of proc boogie_si_record_ref
 Adding procedure: $initialize
 Empty block name founded in proc $initialize
 inlining procedure: main
 $bb0_main_0 1 0
 New stmts! 
 call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
 call $p0_main0 := malloc(8);
 $p1_main0 := $bitcast.ref.ref($p0_main0);
 $M.0 := $p0_main0;
 call $i2_main0 := atexit(free_g1_main0);
 call $i3_main0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
 assume true;
 goto $bb1_main_0, $bb2_main_0;
 
 $bb1_main_0 1 0
 New stmts! 
 assume ($i3_main0 == 1);
 call exit(1);
 assume false;
 
 $bb2_main_0 2 1
 New stmts! 
 assume !(($i3_main0 == 1));
 
 New stmts! 
 $r_main0 := 0;
 return;
 
 call f();
 inlining procedure: f
 $bb0_f_0 2 1
 New stmts! 
 call $p0_f0 := malloc(4);
 $p1_f0 := $bitcast.ref.ref($p0_f0);
 $p2_f0 := $M.0;
 $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
 call $i3_f0 := atexit(free_g2_f0);
 
 New stmts! 
 return;
 
 call h();
 inlining procedure: h
 $bb0_h_0 1 0
 New stmts! 
 call $i0_h0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
 assume true;
 goto $bb1_h_0, $bb2_h_0;
 
 $bb1_h_0 1 0
 New stmts! 
 assume ($i0_h0 == 1);
 call _Exit(1);
 assume false;
 
 
 Inlining procedure: h 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb2_h_0
 return param of 'call h();': 
 	return to: 
 	Add goto relation: $bb2_f_0 -> $bb1_f_0
 Return block: $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 Return process block: $bb2_f_0:
   goto $bb1_f_0;
 Current block: $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 Pass block: $bb3_f_0:
   goto $bb0_h_0;
 Splitting return block
 
 Inlining procedure: f 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb1_f_0
 return param of 'call f();': 
 	return to: 
 	Add goto relation: $bb4_main_0 -> $bb3_main_0
 Return block: $bb1_f_0:
   goto $bb4_main_0;
 Return process block: $bb4_main_0:
   goto $bb3_main_0;
 Current block: $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 Pass block: $bb5_main_0:
   goto $bb0_f_0;
 Splitting return block
 =====================CENTER NEW===================
 procedure main()
   returns ($r_main0: i32)
 {
   var $p0_main0: ref8;
   var $p1_main0: ref;
   var $i2_main0: i32;
   var $i3_main0: i1;
   var $r_main0: i32;
   var $p0_f0: ref8;
   var $p1_f0: ref32;
   var $p2_f0: ref;
   var $i3_f0: i32;
   var $i0_h0: i1;
 $bb0_main_0:
   call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
   call $p0_main0 := malloc(8);
   $p1_main0 := $bitcast.ref.ref($p0_main0);
   $M.0 := $p0_main0;
   call $i2_main0 := atexit(free_g1_main0);
   call $i3_main0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
   assume true;
   goto $bb1_main_0, $bb2_main_0;
 $bb1_main_0:
   assume ($i3_main0 == 1);
   call exit(1);
   assume false;
 $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 $bb4_main_0:
   goto $bb3_main_0;
 $bb5_main_0:
   goto $bb0_f_0;
 $bb3_main_0:
   $r_main0 := 0;
   return;
 $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 $bb2_f_0:
   goto $bb1_f_0;
 $bb3_f_0:
   goto $bb0_h_0;
 $bb1_f_0:
   goto $bb4_main_0;
 $bb0_h_0:
   call $i0_h0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
   assume true;
   goto $bb1_h_0, $bb2_h_0;
 $bb1_h_0:
   assume ($i0_h0 == 1);
   call _Exit(1);
   assume false;
 $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 }
 =====================CENTER NEW===================
 from bb: $bb0_main_0 to bb: $bb1_main_0 $bb2_main_0 
 from bb: $bb2_main_0 to bb: $bb5_main_0 
 from bb: $bb4_main_0 to bb: $bb3_main_0 
 from bb: $bb5_main_0 to bb: $bb0_f_0 
 from bb: $bb0_f_0 to bb: $bb3_f_0 
 from bb: $bb2_f_0 to bb: $bb1_f_0 
 from bb: $bb3_f_0 to bb: $bb0_h_0 
 from bb: $bb1_f_0 to bb: $bb4_main_0 
 from bb: $bb0_h_0 to bb: $bb1_h_0 $bb2_h_0 
 from bb: $bb2_h_0 to bb: $bb2_f_0 
 In $bb1_main_0
 [0mpop: $bb1_main_0
 [0mpop finished
 [0mIn $bb1_h_0
 [0mpop: $bb1_h_0
 [0mpop finished
 [0mIn $bb3_main_0
 [0mpop: $bb3_main_0
 [0mpop finished
 [0mIn $bb4_main_0
 [0mpop: $bb4_main_0
 [0mpop finished
 [0mIn $bb1_f_0
 [0mpop: $bb1_f_0
 [0mpop finished
 [0mIn $bb2_f_0
 [0mpop: $bb2_f_0
 [0mpop finished
 [0mIn $bb2_h_0
 [0mpop: $bb2_h_0
 [0mpop finished
 [0mIn $bb0_h_0
 [0mpop: $bb0_h_0
 [0mpop finished
 [0mIn $bb3_f_0
 [0mpop: $bb3_f_0
 [0mpop finished
 [0mIn $bb0_f_0
 [0mpop: $bb0_f_0
 [0mpop finished
 [0mIn $bb5_main_0
 [0mpop: $bb5_main_0
 [0mpop finished
 [0mIn $bb2_main_0
 [0mpop: $bb2_main_0
 [0mpop finished
 [0mIn $bb0_main_0
 [0mpop: $bb0_main_0
 [0mpop finished
 [0mIn pro:$bb0_main_0 1 $bb1_main_0 $bb2_main_0 
 In pro:$bb2_main_0 1 $bb5_main_0 
 In pro:$bb5_main_0 1 $bb0_f_0 
 In pro:$bb0_f_0 1 $bb3_f_0 
 In pro:$bb3_f_0 1 $bb0_h_0 
 In pro:$bb0_h_0 1 $bb1_h_0 $bb2_h_0 
 In pro:$bb2_h_0 1 $bb2_f_0 
 In pro:$bb2_f_0 1 $bb1_f_0 
 In pro:$bb1_f_0 1 $bb4_main_0 
 In pro:$bb4_main_0 1 $bb3_main_0 
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0m[34mUNSOLVED VERIFIER FUNC: __VERIFIER_nondet_bool
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume ($i3_main0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mWARNING: This is not correct use, please check, getVar after useVar
 [0m[34mINFO: Basic Parse condition, 4
  #0 0x00007f37bf5034ff llvm::sys::PrintStackTrace(llvm::raw_ostream&) (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x9814ff)
  #1 0x00007f37bf501782 llvm::sys::RunSignalHandlers() (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x97f782)
  #2 0x00007f37bf503ac5 (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x981ac5)
  #3 0x00007f37bd31d210 (/lib/x86_64-linux-gnu/libc.so.6+0x46210)
  #4 0x00000000004c9d38 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:374:12
  #5 0x00000000004cb028 smack::BinExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:464:26
  #6 0x00000000004c9d41 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:375:16
  #7 0x00000000004cb1e5 smack::BinExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:518:26
  #8 0x00000000004c9d41 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:375:16
  #9 0x00000000004d0f78 smack::SymbolicHeapExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:1266:35
 #10 0x0000000000512ca8 smack::BlockExecutor::executeAssume(std::shared_ptr<smack::SymbolicHeapExpr>, smack::Stmt const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:658:20
 #11 0x0000000000516fc3 smack::BlockExecutor::executeStmt(std::shared_ptr<smack::SymbolicHeapExpr>, smack::Stmt const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:1708:13
 #12 0x00000000005172bc smack::BlockExecutor::execute[abi:cxx11](std::shared_ptr<smack::ExecutionState>) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:1736:31
 #13 0x00000000004aa77e smack::MemSafeVerifier::runOnModule(llvm::Module&) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/MemSafeVerifier.cpp:76:69
 #14 0x00007f37bf6094a0 llvm::legacy::PassManagerImpl::run(llvm::Module&) (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0xa874a0)
 #15 0x000000000042bf91 main /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../tools/llvm2bpl/llvm2bpl.cpp:278:17
 #16 0x00007f37bd2fe0b3 __libc_start_main /build/glibc-YbNSs7/glibc-2.31/csu/../csu/libc-start.c:342:3
 #17 0x000000000042a60e _start (/usr/local/bin/llvm2bpl+0x42a60e)
 Stack dump:
 0.	Program arguments: llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-go85jubk.bc -bpl ../svcomp/memsafety//global-atexit-1.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-1_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak 
 1.	Running pass 'MemSafeVerifier' on module '/home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-go85jubk.bc'.
 