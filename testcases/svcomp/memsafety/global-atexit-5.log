SMACK program verifier version 2.6.3
Running clang -c -emit-llvm -O0 -g -gcolumn-info -Xclang -disable-O0-optnone -I/usr/local/share/smack/include -DMEMORY_MODEL_NO_REUSE_IMPLS -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-71vn35do.bc ../svcomp/memsafety//global-atexit-5.c
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-mi0du85q.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-71vn35do.bc
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-346lhc99.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-mi0du85q.bc
Running llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-346lhc99.bc -bpl ../svcomp/memsafety//global-atexit-5.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-5_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak
[regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 -----------------START MEMSAFE ANALYSIS---------------
 Begin verifying
 Adding procedure: free_g1
 Empty block name founded in proc free_g1
 Adding procedure: free_
 Empty block name founded in proc free_
 Adding procedure: free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Adding procedure: h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Adding procedure: __VERIFIER_nondet_bool
 Empty blocks of proc __VERIFIER_nondet_bool
 Adding procedure: exit
 Empty blocks of proc exit
 Adding procedure: f
 Empty block name founded in proc f
 Adding procedure: malloc
 Empty block name founded in proc malloc
 Adding procedure: atexit
 Empty blocks of proc atexit
 Adding procedure: main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Adding procedure: __SMACK_static_init
 Empty block name founded in proc __SMACK_static_init
 Adding procedure: boogie_si_record_i1
 Empty blocks of proc boogie_si_record_i1
 Adding procedure: boogie_si_record_ref
 Empty blocks of proc boogie_si_record_ref
 Adding procedure: $initialize
 Empty block name founded in proc $initialize
 inlining procedure: main
 $bb0_main_0 1 0
 New stmts! 
 call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
 call $p0_main0 := malloc(8);
 $p1_main0 := $bitcast.ref.ref($p0_main0);
 $M.0 := $p0_main0;
 call $i2_main0 := atexit(free_g1_main0);
 call $i3_main0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
 assume true;
 goto $bb1_main_0, $bb2_main_0;
 
 $bb1_main_0 1 0
 New stmts! 
 assume ($i3_main0 == 1);
 call exit(1);
 assume false;
 
 $bb2_main_0 2 1
 New stmts! 
 assume !(($i3_main0 == 1));
 
 New stmts! 
 $p4_main0 := $M.0;
 $p5_main0 := $load.ref($M.1, $p4_main0);
 $p6_main0 := $bitcast.ref.ref($p5_main0);
 call free_($p6_main0);
 $p7_main0 := $M.0;
 $p8_main0 := $bitcast.ref.ref($p7_main0);
 call free_($p8_main0);
 $r_main0 := 0;
 return;
 
 call f();
 inlining procedure: f
 $bb0_f_0 2 1
 New stmts! 
 call $p0_f0 := malloc(4);
 $p1_f0 := $bitcast.ref.ref($p0_f0);
 $p2_f0 := $M.0;
 $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
 call $i3_f0 := atexit(free_g2_f0);
 
 New stmts! 
 return;
 
 call h();
 inlining procedure: h
 $bb0_h_0 1 0
 New stmts! 
 call $i0_h0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
 assume true;
 goto $bb1_h_0, $bb2_h_0;
 
 $bb1_h_0 1 0
 New stmts! 
 assume ($i0_h0 == 1);
 call exit(1);
 assume false;
 
 
 Inlining procedure: h 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb2_h_0
 return param of 'call h();': 
 	return to: 
 	Add goto relation: $bb2_f_0 -> $bb1_f_0
 Return block: $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 Return process block: $bb2_f_0:
   goto $bb1_f_0;
 Current block: $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 Pass block: $bb3_f_0:
   goto $bb0_h_0;
 Splitting return block
 
 Inlining procedure: f 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb1_f_0
 return param of 'call f();': 
 	return to: 
 	Add goto relation: $bb4_main_0 -> $bb3_main_0
 Return block: $bb1_f_0:
   goto $bb4_main_0;
 Return process block: $bb4_main_0:
   goto $bb3_main_0;
 Current block: $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 Pass block: $bb5_main_0:
   goto $bb0_f_0;
 Splitting return block
 =====================CENTER NEW===================
 procedure main()
   returns ($r_main0: i32)
 {
   var $p0_main0: ref8;
   var $p1_main0: ref;
   var $i2_main0: i32;
   var $i3_main0: i1;
   var $p4_main0: ref;
   var $p5_main0: ref32;
   var $p6_main0: ref8;
   var $p7_main0: ref;
   var $p8_main0: ref8;
   var $r_main0: i32;
   var $p0_f0: ref8;
   var $p1_f0: ref32;
   var $p2_f0: ref;
   var $i3_f0: i32;
   var $i0_h0: i1;
 $bb0_main_0:
   call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
   call $p0_main0 := malloc(8);
   $p1_main0 := $bitcast.ref.ref($p0_main0);
   $M.0 := $p0_main0;
   call $i2_main0 := atexit(free_g1_main0);
   call $i3_main0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
   assume true;
   goto $bb1_main_0, $bb2_main_0;
 $bb1_main_0:
   assume ($i3_main0 == 1);
   call exit(1);
   assume false;
 $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 $bb4_main_0:
   goto $bb3_main_0;
 $bb5_main_0:
   goto $bb0_f_0;
 $bb3_main_0:
   $p4_main0 := $M.0;
   $p5_main0 := $load.ref($M.1, $p4_main0);
   $p6_main0 := $bitcast.ref.ref($p5_main0);
   call free_($p6_main0);
   $p7_main0 := $M.0;
   $p8_main0 := $bitcast.ref.ref($p7_main0);
   call free_($p8_main0);
   $r_main0 := 0;
   return;
 $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 $bb2_f_0:
   goto $bb1_f_0;
 $bb3_f_0:
   goto $bb0_h_0;
 $bb1_f_0:
   goto $bb4_main_0;
 $bb0_h_0:
   call $i0_h0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
   assume true;
   goto $bb1_h_0, $bb2_h_0;
 $bb1_h_0:
   assume ($i0_h0 == 1);
   call exit(1);
   assume false;
 $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 }
 =====================CENTER NEW===================
 from bb: $bb0_main_0 to bb: $bb1_main_0 $bb2_main_0 
 from bb: $bb2_main_0 to bb: $bb5_main_0 
 from bb: $bb4_main_0 to bb: $bb3_main_0 
 from bb: $bb5_main_0 to bb: $bb0_f_0 
 from bb: $bb0_f_0 to bb: $bb3_f_0 
 from bb: $bb2_f_0 to bb: $bb1_f_0 
 from bb: $bb3_f_0 to bb: $bb0_h_0 
 from bb: $bb1_f_0 to bb: $bb4_main_0 
 from bb: $bb0_h_0 to bb: $bb1_h_0 $bb2_h_0 
 from bb: $bb2_h_0 to bb: $bb2_f_0 
 In $bb1_main_0
 [0mpop: $bb1_main_0
 [0mpop finished
 [0mIn $bb1_h_0
 [0mpop: $bb1_h_0
 [0mpop finished
 [0mIn $bb3_main_0
 [0mpop: $bb3_main_0
 [0mpop finished
 [0mIn $bb4_main_0
 [0mpop: $bb4_main_0
 [0mpop finished
 [0mIn $bb1_f_0
 [0mpop: $bb1_f_0
 [0mpop finished
 [0mIn $bb2_f_0
 [0mpop: $bb2_f_0
 [0mpop finished
 [0mIn $bb2_h_0
 [0mpop: $bb2_h_0
 [0mpop finished
 [0mIn $bb0_h_0
 [0mpop: $bb0_h_0
 [0mpop finished
 [0mIn $bb3_f_0
 [0mpop: $bb3_f_0
 [0mpop finished
 [0mIn $bb0_f_0
 [0mpop: $bb0_f_0
 [0mpop finished
 [0mIn $bb5_main_0
 [0mpop: $bb5_main_0
 [0mpop finished
 [0mIn $bb2_main_0
 [0mpop: $bb2_main_0
 [0mpop finished
 [0mIn $bb0_main_0
 [0mpop: $bb0_main_0
 [0mpop finished
 [0mIn pro:$bb0_main_0 1 $bb1_main_0 $bb2_main_0 
 In pro:$bb2_main_0 1 $bb5_main_0 
 In pro:$bb5_main_0 1 $bb0_f_0 
 In pro:$bb0_f_0 1 $bb3_f_0 
 In pro:$bb3_f_0 1 $bb0_h_0 
 In pro:$bb0_h_0 1 $bb1_h_0 $bb2_h_0 
 In pro:$bb2_h_0 1 $bb2_f_0 
 In pro:$bb2_f_0 1 $bb1_f_0 
 In pro:$bb1_f_0 1 $bb4_main_0 
 In pro:$bb4_main_0 1 $bb3_main_0 
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0m[34mUNSOLVED VERIFIER FUNC: __VERIFIER_nondet_bool
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume ($i3_main0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mWARNING: This is not correct use, please check, getVar after useVar
 [0m[34mINFO: Basic Parse condition, 4
  #0 0x00007ff31a3354ff llvm::sys::PrintStackTrace(llvm::raw_ostream&) (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x9814ff)
  #1 0x00007ff31a333782 llvm::sys::RunSignalHandlers() (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x97f782)
  #2 0x00007ff31a335ac5 (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x981ac5)
  #3 0x00007ff31814f210 (/lib/x86_64-linux-gnu/libc.so.6+0x46210)
  #4 0x00000000004c9d38 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:374:12
  #5 0x00000000004cb028 smack::BinExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:464:26
  #6 0x00000000004c9d41 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:375:16
  #7 0x00000000004cb1e5 smack::BinExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:518:26
  #8 0x00000000004c9d41 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:375:16
  #9 0x00000000004d0f78 smack::SymbolicHeapExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:1266:35
 #10 0x0000000000512ca8 smack::BlockExecutor::executeAssume(std::shared_ptr<smack::SymbolicHeapExpr>, smack::Stmt const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:658:20
 #11 0x0000000000516fc3 smack::BlockExecutor::executeStmt(std::shared_ptr<smack::SymbolicHeapExpr>, smack::Stmt const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:1708:13
 #12 0x00000000005172bc smack::BlockExecutor::execute[abi:cxx11](std::shared_ptr<smack::ExecutionState>) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:1736:31
 #13 0x00000000004aa77e smack::MemSafeVerifier::runOnModule(llvm::Module&) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/MemSafeVerifier.cpp:76:69
 #14 0x00007ff31a43b4a0 llvm::legacy::PassManagerImpl::run(llvm::Module&) (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0xa874a0)
 #15 0x000000000042bf91 main /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../tools/llvm2bpl/llvm2bpl.cpp:278:17
 #16 0x00007ff3181300b3 __libc_start_main /build/glibc-YbNSs7/glibc-2.31/csu/../csu/libc-start.c:342:3
 #17 0x000000000042a60e _start (/usr/local/bin/llvm2bpl+0x42a60e)
 Stack dump:
 0.	Program arguments: llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-346lhc99.bc -bpl ../svcomp/memsafety//global-atexit-5.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-5_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak 
 1.	Running pass 'MemSafeVerifier' on module '/home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-346lhc99.bc'.
 SMACK program verifier version 2.6.3
Running clang -c -emit-llvm -O0 -g -gcolumn-info -Xclang -disable-O0-optnone -I/usr/local/share/smack/include -DMEMORY_MODEL_NO_REUSE_IMPLS -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-4x2xmovb.bc ../svcomp/memsafety//global-atexit-5.c
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-88f2vuer.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-4x2xmovb.bc
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-vqnmrxkn.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-88f2vuer.bc
Running llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-vqnmrxkn.bc -bpl ../svcomp/memsafety//global-atexit-5.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-5_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak
[regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 -----------------START MEMSAFE ANALYSIS---------------
 Begin verifying
 Adding procedure: free_g1
 Empty block name founded in proc free_g1
 Adding procedure: free_
 Empty block name founded in proc free_
 Adding procedure: free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Adding procedure: h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Adding procedure: __VERIFIER_nondet_bool
 Empty blocks of proc __VERIFIER_nondet_bool
 Adding procedure: exit
 Empty blocks of proc exit
 Adding procedure: f
 Empty block name founded in proc f
 Adding procedure: malloc
 Empty block name founded in proc malloc
 Adding procedure: atexit
 Empty blocks of proc atexit
 Adding procedure: main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Adding procedure: __SMACK_static_init
 Empty block name founded in proc __SMACK_static_init
 Adding procedure: boogie_si_record_i1
 Empty blocks of proc boogie_si_record_i1
 Adding procedure: boogie_si_record_ref
 Empty blocks of proc boogie_si_record_ref
 Adding procedure: $initialize
 Empty block name founded in proc $initialize
 inlining procedure: main
 $bb0_main_0 1 0
 New stmts! 
 call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
 call $p0_main0 := malloc(8);
 $p1_main0 := $bitcast.ref.ref($p0_main0);
 $M.0 := $p0_main0;
 call $i2_main0 := atexit(free_g1_main0);
 call $i3_main0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
 assume true;
 goto $bb1_main_0, $bb2_main_0;
 
 $bb1_main_0 1 0
 New stmts! 
 assume ($i3_main0 == 1);
 call exit(1);
 assume false;
 
 $bb2_main_0 2 1
 New stmts! 
 assume !(($i3_main0 == 1));
 
 New stmts! 
 $p4_main0 := $M.0;
 $p5_main0 := $load.ref($M.1, $p4_main0);
 $p6_main0 := $bitcast.ref.ref($p5_main0);
 call free_($p6_main0);
 $p7_main0 := $M.0;
 $p8_main0 := $bitcast.ref.ref($p7_main0);
 call free_($p8_main0);
 $r_main0 := 0;
 return;
 
 call f();
 inlining procedure: f
 $bb0_f_0 2 1
 New stmts! 
 call $p0_f0 := malloc(4);
 $p1_f0 := $bitcast.ref.ref($p0_f0);
 $p2_f0 := $M.0;
 $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
 call $i3_f0 := atexit(free_g2_f0);
 
 New stmts! 
 return;
 
 call h();
 inlining procedure: h
 $bb0_h_0 1 0
 New stmts! 
 call $i0_h0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
 assume true;
 goto $bb1_h_0, $bb2_h_0;
 
 $bb1_h_0 1 0
 New stmts! 
 assume ($i0_h0 == 1);
 call exit(1);
 assume false;
 
 
 Inlining procedure: h 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb2_h_0
 return param of 'call h();': 
 	return to: 
 	Add goto relation: $bb2_f_0 -> $bb1_f_0
 Return block: $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 Return process block: $bb2_f_0:
   goto $bb1_f_0;
 Current block: $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 Pass block: $bb3_f_0:
   goto $bb0_h_0;
 Splitting return block
 
 Inlining procedure: f 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb1_f_0
 return param of 'call f();': 
 	return to: 
 	Add goto relation: $bb4_main_0 -> $bb3_main_0
 Return block: $bb1_f_0:
   goto $bb4_main_0;
 Return process block: $bb4_main_0:
   goto $bb3_main_0;
 Current block: $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 Pass block: $bb5_main_0:
   goto $bb0_f_0;
 Splitting return block
 =====================CENTER NEW===================
 procedure main()
   returns ($r_main0: i32)
 {
   var $p0_main0: ref8;
   var $p1_main0: ref;
   var $i2_main0: i32;
   var $i3_main0: i1;
   var $p4_main0: ref;
   var $p5_main0: ref32;
   var $p6_main0: ref8;
   var $p7_main0: ref;
   var $p8_main0: ref8;
   var $r_main0: i32;
   var $p0_f0: ref8;
   var $p1_f0: ref32;
   var $p2_f0: ref;
   var $i3_f0: i32;
   var $i0_h0: i1;
 $bb0_main_0:
   call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
   call $p0_main0 := malloc(8);
   $p1_main0 := $bitcast.ref.ref($p0_main0);
   $M.0 := $p0_main0;
   call $i2_main0 := atexit(free_g1_main0);
   call $i3_main0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
   assume true;
   goto $bb1_main_0, $bb2_main_0;
 $bb1_main_0:
   assume ($i3_main0 == 1);
   call exit(1);
   assume false;
 $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 $bb4_main_0:
   goto $bb3_main_0;
 $bb5_main_0:
   goto $bb0_f_0;
 $bb3_main_0:
   $p4_main0 := $M.0;
   $p5_main0 := $load.ref($M.1, $p4_main0);
   $p6_main0 := $bitcast.ref.ref($p5_main0);
   call free_($p6_main0);
   $p7_main0 := $M.0;
   $p8_main0 := $bitcast.ref.ref($p7_main0);
   call free_($p8_main0);
   $r_main0 := 0;
   return;
 $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 $bb2_f_0:
   goto $bb1_f_0;
 $bb3_f_0:
   goto $bb0_h_0;
 $bb1_f_0:
   goto $bb4_main_0;
 $bb0_h_0:
   call $i0_h0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
   assume true;
   goto $bb1_h_0, $bb2_h_0;
 $bb1_h_0:
   assume ($i0_h0 == 1);
   call exit(1);
   assume false;
 $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 }
 =====================CENTER NEW===================
 from bb: $bb0_main_0 to bb: $bb1_main_0 $bb2_main_0 
 from bb: $bb2_main_0 to bb: $bb5_main_0 
 from bb: $bb4_main_0 to bb: $bb3_main_0 
 from bb: $bb5_main_0 to bb: $bb0_f_0 
 from bb: $bb0_f_0 to bb: $bb3_f_0 
 from bb: $bb2_f_0 to bb: $bb1_f_0 
 from bb: $bb3_f_0 to bb: $bb0_h_0 
 from bb: $bb1_f_0 to bb: $bb4_main_0 
 from bb: $bb0_h_0 to bb: $bb1_h_0 $bb2_h_0 
 from bb: $bb2_h_0 to bb: $bb2_f_0 
 In $bb1_main_0
 [0mpop: $bb1_main_0
 [0mpop finished
 [0mIn $bb1_h_0
 [0mpop: $bb1_h_0
 [0mpop finished
 [0mIn $bb3_main_0
 [0mpop: $bb3_main_0
 [0mpop finished
 [0mIn $bb4_main_0
 [0mpop: $bb4_main_0
 [0mpop finished
 [0mIn $bb1_f_0
 [0mpop: $bb1_f_0
 [0mpop finished
 [0mIn $bb2_f_0
 [0mpop: $bb2_f_0
 [0mpop finished
 [0mIn $bb2_h_0
 [0mpop: $bb2_h_0
 [0mpop finished
 [0mIn $bb0_h_0
 [0mpop: $bb0_h_0
 [0mpop finished
 [0mIn $bb3_f_0
 [0mpop: $bb3_f_0
 [0mpop finished
 [0mIn $bb0_f_0
 [0mpop: $bb0_f_0
 [0mpop finished
 [0mIn $bb5_main_0
 [0mpop: $bb5_main_0
 [0mpop finished
 [0mIn $bb2_main_0
 [0mpop: $bb2_main_0
 [0mpop finished
 [0mIn $bb0_main_0
 [0mpop: $bb0_main_0
 [0mpop finished
 [0mIn pro:$bb0_main_0 1 $bb1_main_0 $bb2_main_0 
 In pro:$bb2_main_0 1 $bb5_main_0 
 In pro:$bb5_main_0 1 $bb0_f_0 
 In pro:$bb0_f_0 1 $bb3_f_0 
 In pro:$bb3_f_0 1 $bb0_h_0 
 In pro:$bb0_h_0 1 $bb1_h_0 $bb2_h_0 
 In pro:$bb2_h_0 1 $bb2_f_0 
 In pro:$bb2_f_0 1 $bb1_f_0 
 In pro:$bb1_f_0 1 $bb4_main_0 
 In pro:$bb4_main_0 1 $bb3_main_0 
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0m[34mUNSOLVED VERIFIER FUNC: __VERIFIER_nondet_bool
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume ($i3_main0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mWARNING: This is not correct use, please check, getVar after useVar
 [0m[34mINFO: Basic Parse condition, 4
  #0 0x00007f5fa1d044ff llvm::sys::PrintStackTrace(llvm::raw_ostream&) (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x9814ff)
  #1 0x00007f5fa1d02782 llvm::sys::RunSignalHandlers() (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x97f782)
  #2 0x00007f5fa1d04ac5 (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0x981ac5)
  #3 0x00007f5f9fb1e210 (/lib/x86_64-linux-gnu/libc.so.6+0x46210)
  #4 0x00000000004c9d38 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:374:12
  #5 0x00000000004cb028 smack::BinExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:464:26
  #6 0x00000000004c9d41 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:375:16
  #7 0x00000000004cb1e5 smack::BinExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:518:26
  #8 0x00000000004c9d41 smack::operator<<(std::ostream&, smack::Expr const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:375:16
  #9 0x00000000004d0f78 smack::SymbolicHeapExpr::print(std::ostream&) const /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BoogieAst.cpp:1266:35
 #10 0x0000000000512ca8 smack::BlockExecutor::executeAssume(std::shared_ptr<smack::SymbolicHeapExpr>, smack::Stmt const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:658:20
 #11 0x0000000000516fc3 smack::BlockExecutor::executeStmt(std::shared_ptr<smack::SymbolicHeapExpr>, smack::Stmt const*) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:1708:13
 #12 0x00000000005172bc smack::BlockExecutor::execute[abi:cxx11](std::shared_ptr<smack::ExecutionState>) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/BlockExecutor.cpp:1736:31
 #13 0x00000000004aa77e smack::MemSafeVerifier::runOnModule(llvm::Module&) /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../lib/smack/MemSafeVerifier.cpp:76:69
 #14 0x00007f5fa1e0a4a0 llvm::legacy::PassManagerImpl::run(llvm::Module&) (/lib/x86_64-linux-gnu/libLLVM-10.so.1+0xa874a0)
 #15 0x000000000042bf91 main /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/build/../tools/llvm2bpl/llvm2bpl.cpp:278:17
 #16 0x00007f5f9faff0b3 __libc_start_main /build/glibc-YbNSs7/glibc-2.31/csu/../csu/libc-start.c:342:3
 #17 0x000000000042a60e _start (/usr/local/bin/llvm2bpl+0x42a60e)
 Stack dump:
 0.	Program arguments: llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-vqnmrxkn.bc -bpl ../svcomp/memsafety//global-atexit-5.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-5_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak 
 1.	Running pass 'MemSafeVerifier' on module '/home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-vqnmrxkn.bc'.
 SMACK program verifier version 2.6.3
Running clang -c -emit-llvm -O0 -g -gcolumn-info -Xclang -disable-O0-optnone -I/usr/local/share/smack/include -DMEMORY_MODEL_NO_REUSE_IMPLS -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-16jovmu4.bc ../svcomp/memsafety//global-atexit-5.c
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-jl43e05o.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-16jovmu4.bc
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-0h9qb5f8.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-jl43e05o.bc
Running llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-0h9qb5f8.bc -bpl ../svcomp/memsafety//global-atexit-5.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-5_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak
[regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 -----------------START MEMSAFE ANALYSIS---------------
 Begin verifying
 Adding procedure: free_g1
 Empty block name founded in proc free_g1
 Adding procedure: free_
 Empty block name founded in proc free_
 Adding procedure: free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Adding procedure: h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Adding procedure: __VERIFIER_nondet_bool
 Empty blocks of proc __VERIFIER_nondet_bool
 Adding procedure: exit
 Empty blocks of proc exit
 Adding procedure: f
 Empty block name founded in proc f
 Adding procedure: malloc
 Empty block name founded in proc malloc
 Adding procedure: atexit
 Empty blocks of proc atexit
 Adding procedure: main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Adding procedure: __SMACK_static_init
 Empty block name founded in proc __SMACK_static_init
 Adding procedure: boogie_si_record_i1
 Empty blocks of proc boogie_si_record_i1
 Adding procedure: boogie_si_record_ref
 Empty blocks of proc boogie_si_record_ref
 Adding procedure: $initialize
 Empty block name founded in proc $initialize
 inlining procedure: main
 $bb0_main_0 1 0
 New stmts! 
 call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
 call $p0_main0 := malloc(8);
 $p1_main0 := $bitcast.ref.ref($p0_main0);
 $M.0 := $p0_main0;
 call $i2_main0 := atexit(free_g1_main0);
 call $i3_main0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
 assume true;
 goto $bb1_main_0, $bb2_main_0;
 
 $bb1_main_0 1 0
 New stmts! 
 assume ($i3_main0 == 1);
 call exit(1);
 assume false;
 
 $bb2_main_0 2 1
 New stmts! 
 assume !(($i3_main0 == 1));
 
 New stmts! 
 $p4_main0 := $M.0;
 $p5_main0 := $load.ref($M.1, $p4_main0);
 $p6_main0 := $bitcast.ref.ref($p5_main0);
 call free_($p6_main0);
 $p7_main0 := $M.0;
 $p8_main0 := $bitcast.ref.ref($p7_main0);
 call free_($p8_main0);
 $r_main0 := 0;
 return;
 
 call f();
 inlining procedure: f
 $bb0_f_0 2 1
 New stmts! 
 call $p0_f0 := malloc(4);
 $p1_f0 := $bitcast.ref.ref($p0_f0);
 $p2_f0 := $M.0;
 $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
 call $i3_f0 := atexit(free_g2_f0);
 
 New stmts! 
 return;
 
 call h();
 inlining procedure: h
 $bb0_h_0 1 0
 New stmts! 
 call $i0_h0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
 assume true;
 goto $bb1_h_0, $bb2_h_0;
 
 $bb1_h_0 1 0
 New stmts! 
 assume ($i0_h0 == 1);
 call exit(1);
 assume false;
 
 
 Inlining procedure: h 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb2_h_0
 return param of 'call h();': 
 	return to: 
 	Add goto relation: $bb2_f_0 -> $bb1_f_0
 Return block: $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 Return process block: $bb2_f_0:
   goto $bb1_f_0;
 Current block: $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 Pass block: $bb3_f_0:
   goto $bb0_h_0;
 Splitting return block
 
 Inlining procedure: f 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb1_f_0
 return param of 'call f();': 
 	return to: 
 	Add goto relation: $bb4_main_0 -> $bb3_main_0
 Return block: $bb1_f_0:
   goto $bb4_main_0;
 Return process block: $bb4_main_0:
   goto $bb3_main_0;
 Current block: $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 Pass block: $bb5_main_0:
   goto $bb0_f_0;
 Splitting return block
 =====================CENTER NEW===================
 procedure main()
   returns ($r_main0: i32)
 {
   var $p0_main0: ref8;
   var $p1_main0: ref;
   var $i2_main0: i32;
   var $i3_main0: i1;
   var $p4_main0: ref;
   var $p5_main0: ref32;
   var $p6_main0: ref8;
   var $p7_main0: ref;
   var $p8_main0: ref8;
   var $r_main0: i32;
   var $p0_f0: ref8;
   var $p1_f0: ref32;
   var $p2_f0: ref;
   var $i3_f0: i32;
   var $i0_h0: i1;
 $bb0_main_0:
   call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
   call $p0_main0 := malloc(8);
   $p1_main0 := $bitcast.ref.ref($p0_main0);
   $M.0 := $p0_main0;
   call $i2_main0 := atexit(free_g1_main0);
   call $i3_main0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
   assume true;
   goto $bb1_main_0, $bb2_main_0;
 $bb1_main_0:
   assume ($i3_main0 == 1);
   call exit(1);
   assume false;
 $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 $bb4_main_0:
   goto $bb3_main_0;
 $bb5_main_0:
   goto $bb0_f_0;
 $bb3_main_0:
   $p4_main0 := $M.0;
   $p5_main0 := $load.ref($M.1, $p4_main0);
   $p6_main0 := $bitcast.ref.ref($p5_main0);
   call free_($p6_main0);
   $p7_main0 := $M.0;
   $p8_main0 := $bitcast.ref.ref($p7_main0);
   call free_($p8_main0);
   $r_main0 := 0;
   return;
 $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 $bb2_f_0:
   goto $bb1_f_0;
 $bb3_f_0:
   goto $bb0_h_0;
 $bb1_f_0:
   goto $bb4_main_0;
 $bb0_h_0:
   call $i0_h0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
   assume true;
   goto $bb1_h_0, $bb2_h_0;
 $bb1_h_0:
   assume ($i0_h0 == 1);
   call exit(1);
   assume false;
 $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 }
 =====================CENTER NEW===================
 from bb: $bb0_main_0 to bb: $bb1_main_0 $bb2_main_0 
 from bb: $bb2_main_0 to bb: $bb5_main_0 
 from bb: $bb4_main_0 to bb: $bb3_main_0 
 from bb: $bb5_main_0 to bb: $bb0_f_0 
 from bb: $bb0_f_0 to bb: $bb3_f_0 
 from bb: $bb2_f_0 to bb: $bb1_f_0 
 from bb: $bb3_f_0 to bb: $bb0_h_0 
 from bb: $bb1_f_0 to bb: $bb4_main_0 
 from bb: $bb0_h_0 to bb: $bb1_h_0 $bb2_h_0 
 from bb: $bb2_h_0 to bb: $bb2_f_0 
 In $bb1_main_0
 [0mpop: $bb1_main_0
 [0mpop finished
 [0mIn $bb1_h_0
 [0mpop: $bb1_h_0
 [0mpop finished
 [0mIn $bb3_main_0
 [0mpop: $bb3_main_0
 [0mpop finished
 [0mIn $bb4_main_0
 [0mpop: $bb4_main_0
 [0mpop finished
 [0mIn $bb1_f_0
 [0mpop: $bb1_f_0
 [0mpop finished
 [0mIn $bb2_f_0
 [0mpop: $bb2_f_0
 [0mpop finished
 [0mIn $bb2_h_0
 [0mpop: $bb2_h_0
 [0mpop finished
 [0mIn $bb0_h_0
 [0mpop: $bb0_h_0
 [0mpop finished
 [0mIn $bb3_f_0
 [0mpop: $bb3_f_0
 [0mpop finished
 [0mIn $bb0_f_0
 [0mpop: $bb0_f_0
 [0mpop finished
 [0mIn $bb5_main_0
 [0mpop: $bb5_main_0
 [0mpop finished
 [0mIn $bb2_main_0
 [0mpop: $bb2_main_0
 [0mpop finished
 [0mIn $bb0_main_0
 [0mpop: $bb0_main_0
 [0mpop finished
 [0mIn pro:$bb0_main_0 1 $bb1_main_0 $bb2_main_0 
 In pro:$bb2_main_0 1 $bb5_main_0 
 In pro:$bb5_main_0 1 $bb0_f_0 
 In pro:$bb0_f_0 1 $bb3_f_0 
 In pro:$bb3_f_0 1 $bb0_h_0 
 In pro:$bb0_h_0 1 $bb1_h_0 $bb2_h_0 
 In pro:$bb2_h_0 1 $bb2_f_0 
 In pro:$bb2_f_0 1 $bb1_f_0 
 In pro:$bb1_f_0 1 $bb4_main_0 
 In pro:$bb4_main_0 1 $bb3_main_0 
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume ($i3_main0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && ($i3_main0_bb0 == 1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall exit(1);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: exit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume false;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && ($i3_main0_bb0 == 1)) && false)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [33m======center test: in pure translate process=======
 [0m[34mtranslating var$p1_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$M.0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[34mtranslating var$fresh1
 [0m[34mtranslating boolvar$fresh1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33m(and true
      true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7)
      true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7)
      (=> $i3_main0_bb0 $fresh1)
      (=> $fresh1 $i3_main0_bb0)
      true
      (=> $i3_main0_bb0 true)
      (=> true $i3_main0_bb0)
      false)
 ((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && ($i3_main0_bb0 == 1)) && false)
 [0m[33m======center test: in spatial translate process======
 [0m[33min emp! emp
 [0m[33msizeptlit
 [0m[34mtranslating var$p0_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn intLint : 8
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33min blk!!! (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7))) (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33m(let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
 (let ((a!3 (+ 0
               (* 1 $p0_main0_bb0_0)
               (* (* 1 256) $p0_main0_bb0_1)
               (* (* (* 1 256) 256) $p0_main0_bb0_2)
               a!1
               (* a!2 $p0_main0_bb0_4)
               (* (* a!2 256) $p0_main0_bb0_5)
               (* (* (* a!2 256) 256) $p0_main0_bb0_6)
               (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7))))
   (sep emp emp (blk a!3 (+ a!3 8)))))
 [0m[32mCHECK: Satisfied, path condition false!
 [0m[32mCHECK: Inference check pass! Path condition unsat...
 [0m=========== END SYMBOLIC EXECUTION FOR ONE BLOCk
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume !(($i3_main0 == 1));[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb5_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_f0 := malloc(4);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 4
 [0m[33mIn intLint : 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_f0 := $bitcast.ref.ref($p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap(((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p2_f0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p2_f0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.1 := $store.ref($M.1, $p2_f0, $p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs store or load
 [0m[34mSTORE: arg1 $p2_f0 arg2: $p0_f0
 [0m[33mIn intLint : 8
 [0m[34mSTORE: offset 0 Blk size: 8
 [0m[34mINFO: new store offset
 [0m[34mmalloc name: $p0_main0_bb0 splitIndex: 1
 [0m[32mWARNING: VarIntMap get warning. $p0_f0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mStore type: ref Store stepsize: 0
 [0mSymbHeap(((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_f0 := atexit(free_g2_f0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i3_f0_bb0 == $fresh3))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb3_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i0_h0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_h_0, $bb2_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume ($i0_h0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && ($i0_h0_bb0 == 1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall exit(1);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: exit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume false;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && ($i0_h0_bb0 == 1)) && false)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [33m======center test: in pure translate process=======
 [0m[34mtranslating var$p1_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$M.0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[34mtranslating var$fresh1
 [0m[34mtranslating boolvar$fresh1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p1_f0_bb0
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_f0_bb0_0 $p0_f0_bb0_0)
      (= $p1_f0_bb0_1 $p0_f0_bb0_1)
      (= $p1_f0_bb0_2 $p0_f0_bb0_2)
      (= $p1_f0_bb0_3 $p0_f0_bb0_3)
      (= $p1_f0_bb0_4 $p0_f0_bb0_4)
      (= $p1_f0_bb0_5 $p0_f0_bb0_5)
      (= $p1_f0_bb0_6 $p0_f0_bb0_6)
      (= $p1_f0_bb0_7 $p0_f0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p2_f0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p2_f0_bb0_0 $M.0_bb0_0)
      (= $p2_f0_bb0_1 $M.0_bb0_1)
      (= $p2_f0_bb0_2 $M.0_bb0_2)
      (= $p2_f0_bb0_3 $M.0_bb0_3)
      (= $p2_f0_bb0_4 $M.0_bb0_4)
      (= $p2_f0_bb0_5 $M.0_bb0_5)
      (= $p2_f0_bb0_6 $M.0_bb0_6)
      (= $p2_f0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$fresh2
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: true
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[34mtranslating var$fresh4
 [0m[34mtranslating boolvar$fresh4
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33m(and true
      true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7)
      true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7)
      (=> $i3_main0_bb0 $fresh1)
      (=> $fresh1 $i3_main0_bb0)
      true
      (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
      true
      (= $p1_f0_bb0_0 $p0_f0_bb0_0)
      (= $p1_f0_bb0_1 $p0_f0_bb0_1)
      (= $p1_f0_bb0_2 $p0_f0_bb0_2)
      (= $p1_f0_bb0_3 $p0_f0_bb0_3)
      (= $p1_f0_bb0_4 $p0_f0_bb0_4)
      (= $p1_f0_bb0_5 $p0_f0_bb0_5)
      (= $p1_f0_bb0_6 $p0_f0_bb0_6)
      (= $p1_f0_bb0_7 $p0_f0_bb0_7)
      true
      (= $p2_f0_bb0_0 $M.0_bb0_0)
      (= $p2_f0_bb0_1 $M.0_bb0_1)
      (= $p2_f0_bb0_2 $M.0_bb0_2)
      (= $p2_f0_bb0_3 $M.0_bb0_3)
      (= $p2_f0_bb0_4 $M.0_bb0_4)
      (= $p2_f0_bb0_5 $M.0_bb0_5)
      (= $p2_f0_bb0_6 $M.0_bb0_6)
      (= $p2_f0_bb0_7 $M.0_bb0_7)
      true
      (=> $i0_h0_bb0 $fresh4)
      (=> $fresh4 $i0_h0_bb0)
      true
      (=> $i0_h0_bb0 true)
      (=> true $i0_h0_bb0)
      false)
 ((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && ($i0_h0_bb0 == 1)) && false)
 [0m[33m======center test: in spatial translate process======
 [0m[33min emp! emp
 [0m[33msizeptlit
 [0m[33min ptlit!emp
 [0m[34mtranslating var$p2_f0_bb0
 [0m[33mIn intLint : 0
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p2_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p2_f0_bb0_0)
      (* (* 1 256) $p2_f0_bb0_1)
      (* (* (* 1 256) 256) $p2_f0_bb0_2)
      a!1
      (* a!2 $p2_f0_bb0_4)
      (* (* a!2 256) $p2_f0_bb0_5)
      (* (* (* a!2 256) 256) $p2_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p2_f0_bb0_7)
      0))
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn intLint : 8
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33min blk!!! (let ((a!1 (* (* (* (* 1 256) 256) 256) $p2_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p2_f0_bb0_0)
      (* (* 1 256) $p2_f0_bb0_1)
      (* (* (* 1 256) 256) $p2_f0_bb0_2)
      a!1
      (* a!2 $p2_f0_bb0_4)
      (* (* a!2 256) $p2_f0_bb0_5)
      (* (* (* a!2 256) 256) $p2_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p2_f0_bb0_7)
      0)) (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33msizeptlit
 [0m[34mtranslating var$p0_f0_bb0
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn intLint : 4
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_f0_bb0_0)
      (* (* 1 256) $p0_f0_bb0_1)
      (* (* (* 1 256) 256) $p0_f0_bb0_2)
      a!1
      (* a!2 $p0_f0_bb0_4)
      (* (* a!2 256) $p0_f0_bb0_5)
      (* (* (* a!2 256) 256) $p0_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_f0_bb0_7)
      4))
 [0m[33min blk!!! (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_f0_bb0_0)
      (* (* 1 256) $p0_f0_bb0_1)
      (* (* (* 1 256) 256) $p0_f0_bb0_2)
      a!1
      (* a!2 $p0_f0_bb0_4)
      (* (* a!2 256) $p0_f0_bb0_5)
      (* (* (* a!2 256) 256) $p0_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_f0_bb0_7))) (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_f0_bb0_0)
      (* (* 1 256) $p0_f0_bb0_1)
      (* (* (* 1 256) 256) $p0_f0_bb0_2)
      a!1
      (* a!2 $p0_f0_bb0_4)
      (* (* a!2 256) $p0_f0_bb0_5)
      (* (* (* a!2 256) 256) $p0_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_f0_bb0_7)
      4))
 [0m[33m(let ((a!1 (* (* (* (* 1 256) 256) 256) $p2_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256))
       (a!5 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!8 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3)))
 (let ((a!3 (* (* (* (* a!2 256) 256) 256) $p2_f0_bb0_7))
       (a!6 (* (* (* (* a!2 256) 256) 256) $p0_main0_bb0_7))
       (a!9 (* (* (* (* a!2 256) 256) 256) $p0_f0_bb0_7)))
 (let ((a!4 (+ 0
               (* 1 $p2_f0_bb0_0)
               (* (* 1 256) $p2_f0_bb0_1)
               (* (* (* 1 256) 256) $p2_f0_bb0_2)
               a!1
               (* a!2 $p2_f0_bb0_4)
               (* (* a!2 256) $p2_f0_bb0_5)
               (* (* (* a!2 256) 256) $p2_f0_bb0_6)
               a!3
               0))
       (a!7 (+ 0
               (* 1 $p0_main0_bb0_0)
               (* (* 1 256) $p0_main0_bb0_1)
               (* (* (* 1 256) 256) $p0_main0_bb0_2)
               a!5
               (* a!2 $p0_main0_bb0_4)
               (* (* a!2 256) $p0_main0_bb0_5)
               (* (* (* a!2 256) 256) $p0_main0_bb0_6)
               a!6
               8))
       (a!10 (+ 0
                (* 1 $p0_f0_bb0_0)
                (* (* 1 256) $p0_f0_bb0_1)
                (* (* (* 1 256) 256) $p0_f0_bb0_2)
                a!8
                (* a!2 $p0_f0_bb0_4)
                (* (* a!2 256) $p0_f0_bb0_5)
                (* (* (* a!2 256) 256) $p0_f0_bb0_6)
                a!9)))
   (sep emp emp emp emp (blk a!4 a!7) emp (blk a!10 (+ a!10 4))))))
 [0m[32mCHECK: Satisfied, path condition false!
 [0m[32mCHECK: Inference check pass! Path condition unsat...
 [0m=========== END SYMBOLIC EXECUTION FOR ONE BLOCk
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume !(($i3_main0 == 1));[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb5_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_f0 := malloc(4);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 4
 [0m[33mIn intLint : 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p1_f0 := $bitcast.ref.ref($p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap(((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p2_f0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p2_f0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$M.1 := $store.ref($M.1, $p2_f0, $p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs store or load
 [0m[34mSTORE: arg1 $p2_f0 arg2: $p0_f0
 [0m[33mIn intLint : 8
 [0m[34mSTORE: offset 0 Blk size: 8
 [0m[34mINFO: new store offset
 [0m[34mmalloc name: $p0_main0_bb0 splitIndex: 1
 [0m[32mWARNING: VarIntMap get warning. $p0_f0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mStore type: ref Store stepsize: 0
 [0mSymbHeap(((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_f0 := atexit(free_g2_f0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i3_f0_bb0 == $fresh3))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb3_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall $i0_h0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_h_0, $bb2_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0massume !(($i0_h0 == 1));[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb2_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb4_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb3_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p4_main0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p4_main0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p5_main0 := $load.ref($M.1, $p4_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs store or load
 [0m[34mINFO: Load $p4_main0_bb0 to $p5_main0_bb0
 [0m[33mIn intLint : 8
 [0m[34mloadPosResult: 1 1
 [0m[34mINFO: loaded expr: $fresh2
 [0m[32mWARNING: VarIntMap link error. Newname: 0 OldName: 0 $p5_main0_bb0 $fresh2
 [0mSymbHeap((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p6_main0 := $bitcast.ref.ref($p5_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0m[32mERROR: VarEquiv blkoffset no name exists. 
 [0mSymbHeap(((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall free_($p6_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mFreed varname: $p6_main0_bb0
 [0m[34mAlloced varname: $p0_f0_bb0
 [0m[34mLinked Name: $p0_f0_bb0
 [0mSymbHeap(((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p7_main0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p7_main0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$p8_main0 := $bitcast.ref.ref($p7_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap(((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mKey: $p8_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mcall free_($p8_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mFreed varname: $p8_main0_bb0
 [0m[34mAlloced varname: $p0_main0_bb0
 [0m[34mLinked Name: $p0_main0_bb0
 [0mSymbHeap(((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0))|emp)
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mKey: $p8_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0m$r_main0 := 0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr0 $r_main0
 [0m[33mIn intLint : 0
 [0mSymbHeap((((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0)) && ($r_main0_bb0 == 0))|emp)
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $r_main0_bb0| Var: $r_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mKey: $p8_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mKey: $r_main0_bb0| Val: 0
 [0m[34mINFO: executing for stmt: 
 [0mreturn;[34m
 [0m[34mINFO: stmt kind 7
 [0m[33m======center test: in pure translate process=======
 [0m[34mtranslating var$p1_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$M.0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[34mtranslating var$fresh1
 [0m[34mtranslating boolvar$fresh1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p1_f0_bb0
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_f0_bb0_0 $p0_f0_bb0_0)
      (= $p1_f0_bb0_1 $p0_f0_bb0_1)
      (= $p1_f0_bb0_2 $p0_f0_bb0_2)
      (= $p1_f0_bb0_3 $p0_f0_bb0_3)
      (= $p1_f0_bb0_4 $p0_f0_bb0_4)
      (= $p1_f0_bb0_5 $p0_f0_bb0_5)
      (= $p1_f0_bb0_6 $p0_f0_bb0_6)
      (= $p1_f0_bb0_7 $p0_f0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p2_f0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p2_f0_bb0_0 $M.0_bb0_0)
      (= $p2_f0_bb0_1 $M.0_bb0_1)
      (= $p2_f0_bb0_2 $M.0_bb0_2)
      (= $p2_f0_bb0_3 $M.0_bb0_3)
      (= $p2_f0_bb0_4 $M.0_bb0_4)
      (= $p2_f0_bb0_5 $M.0_bb0_5)
      (= $p2_f0_bb0_6 $M.0_bb0_6)
      (= $p2_f0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$fresh2
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: true
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[34mtranslating var$fresh4
 [0m[34mtranslating boolvar$fresh4
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p4_main0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p4_main0_bb0_0 $M.0_bb0_0)
      (= $p4_main0_bb0_1 $M.0_bb0_1)
      (= $p4_main0_bb0_2 $M.0_bb0_2)
      (= $p4_main0_bb0_3 $M.0_bb0_3)
      (= $p4_main0_bb0_4 $M.0_bb0_4)
      (= $p4_main0_bb0_5 $M.0_bb0_5)
      (= $p4_main0_bb0_6 $M.0_bb0_6)
      (= $p4_main0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p5_main0_bb0
 [0m[34mtranslating var$fresh2
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p5_main0_bb0_0 0)
      (= $p5_main0_bb0_1 0)
      (= $p5_main0_bb0_2 0)
      (= $p5_main0_bb0_3 0)
      (= $p5_main0_bb0_4 0)
      (= $p5_main0_bb0_5 0)
      (= $p5_main0_bb0_6 0)
      (= $p5_main0_bb0_7 0))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p6_main0_bb0
 [0m[34mtranslating var$p5_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p6_main0_bb0_0 $p5_main0_bb0_0)
      (= $p6_main0_bb0_1 $p5_main0_bb0_1)
      (= $p6_main0_bb0_2 $p5_main0_bb0_2)
      (= $p6_main0_bb0_3 $p5_main0_bb0_3)
      (= $p6_main0_bb0_4 $p5_main0_bb0_4)
      (= $p6_main0_bb0_5 $p5_main0_bb0_5)
      (= $p6_main0_bb0_6 $p5_main0_bb0_6)
      (= $p6_main0_bb0_7 $p5_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p7_main0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p7_main0_bb0_0 $M.0_bb0_0)
      (= $p7_main0_bb0_1 $M.0_bb0_1)
      (= $p7_main0_bb0_2 $M.0_bb0_2)
      (= $p7_main0_bb0_3 $M.0_bb0_3)
      (= $p7_main0_bb0_4 $M.0_bb0_4)
      (= $p7_main0_bb0_5 $M.0_bb0_5)
      (= $p7_main0_bb0_6 $M.0_bb0_6)
      (= $p7_main0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p8_main0_bb0
 [0m[34mtranslating var$p7_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p8_main0_bb0_0 $p7_main0_bb0_0)
      (= $p8_main0_bb0_1 $p7_main0_bb0_1)
      (= $p8_main0_bb0_2 $p7_main0_bb0_2)
      (= $p8_main0_bb0_3 $p7_main0_bb0_3)
      (= $p8_main0_bb0_4 $p7_main0_bb0_4)
      (= $p8_main0_bb0_5 $p7_main0_bb0_5)
      (= $p8_main0_bb0_6 $p7_main0_bb0_6)
      (= $p8_main0_bb0_7 $p7_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$r_main0_bb0
 [0m[33mIn intLint : 0
 [0m[33mIn binExpr function!
 [0m[34mWARNING: directly let lhs == rhs ...
 [0m[33mIn binExpr function!
 [0m[33m(let ((a!1 (+ 0
               (* 1 $r_main0_bb0_0)
               (* (* 1 256) $r_main0_bb0_1)
               (* (* (* 1 256) 256) $r_main0_bb0_2)
               (* (* (* 1 256) 256) 256 $r_main0_bb0_3))))
   (and true
        true
        (= $p1_main0_bb0_0 $p0_main0_bb0_0)
        (= $p1_main0_bb0_1 $p0_main0_bb0_1)
        (= $p1_main0_bb0_2 $p0_main0_bb0_2)
        (= $p1_main0_bb0_3 $p0_main0_bb0_3)
        (= $p1_main0_bb0_4 $p0_main0_bb0_4)
        (= $p1_main0_bb0_5 $p0_main0_bb0_5)
        (= $p1_main0_bb0_6 $p0_main0_bb0_6)
        (= $p1_main0_bb0_7 $p0_main0_bb0_7)
        true
        (= $M.0_bb0_0 $p0_main0_bb0_0)
        (= $M.0_bb0_1 $p0_main0_bb0_1)
        (= $M.0_bb0_2 $p0_main0_bb0_2)
        (= $M.0_bb0_3 $p0_main0_bb0_3)
        (= $M.0_bb0_4 $p0_main0_bb0_4)
        (= $M.0_bb0_5 $p0_main0_bb0_5)
        (= $M.0_bb0_6 $p0_main0_bb0_6)
        (= $M.0_bb0_7 $p0_main0_bb0_7)
        (=> $i3_main0_bb0 $fresh1)
        (=> $fresh1 $i3_main0_bb0)
        true
        (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
        true
        (= $p1_f0_bb0_0 $p0_f0_bb0_0)
        (= $p1_f0_bb0_1 $p0_f0_bb0_1)
        (= $p1_f0_bb0_2 $p0_f0_bb0_2)
        (= $p1_f0_bb0_3 $p0_f0_bb0_3)
        (= $p1_f0_bb0_4 $p0_f0_bb0_4)
        (= $p1_f0_bb0_5 $p0_f0_bb0_5)
        (= $p1_f0_bb0_6 $p0_f0_bb0_6)
        (= $p1_f0_bb0_7 $p0_f0_bb0_7)
        true
        (= $p2_f0_bb0_0 $M.0_bb0_0)
        (= $p2_f0_bb0_1 $M.0_bb0_1)
        (= $p2_f0_bb0_2 $M.0_bb0_2)
        (= $p2_f0_bb0_3 $M.0_bb0_3)
        (= $p2_f0_bb0_4 $M.0_bb0_4)
        (= $p2_f0_bb0_5 $M.0_bb0_5)
        (= $p2_f0_bb0_6 $M.0_bb0_6)
        (= $p2_f0_bb0_7 $M.0_bb0_7)
        true
        (=> $i0_h0_bb0 $fresh4)
        (=> $fresh4 $i0_h0_bb0)
        true
        (not (and (=> $i0_h0_bb0 true) (=> true $i0_h0_bb0)))
        true
        (= $p4_main0_bb0_0 $M.0_bb0_0)
        (= $p4_main0_bb0_1 $M.0_bb0_1)
        (= $p4_main0_bb0_2 $M.0_bb0_2)
        (= $p4_main0_bb0_3 $M.0_bb0_3)
        (= $p4_main0_bb0_4 $M.0_bb0_4)
        (= $p4_main0_bb0_5 $M.0_bb0_5)
        (= $p4_main0_bb0_6 $M.0_bb0_6)
        (= $p4_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p5_main0_bb0_0 0)
        (= $p5_main0_bb0_1 0)
        (= $p5_main0_bb0_2 0)
        (= $p5_main0_bb0_3 0)
        (= $p5_main0_bb0_4 0)
        (= $p5_main0_bb0_5 0)
        (= $p5_main0_bb0_6 0)
        (= $p5_main0_bb0_7 0)
        true
        (= $p6_main0_bb0_0 $p5_main0_bb0_0)
        (= $p6_main0_bb0_1 $p5_main0_bb0_1)
        (= $p6_main0_bb0_2 $p5_main0_bb0_2)
        (= $p6_main0_bb0_3 $p5_main0_bb0_3)
        (= $p6_main0_bb0_4 $p5_main0_bb0_4)
        (= $p6_main0_bb0_5 $p5_main0_bb0_5)
        (= $p6_main0_bb0_6 $p5_main0_bb0_6)
        (= $p6_main0_bb0_7 $p5_main0_bb0_7)
        true
        (= $p7_main0_bb0_0 $M.0_bb0_0)
        (= $p7_main0_bb0_1 $M.0_bb0_1)
        (= $p7_main0_bb0_2 $M.0_bb0_2)
        (= $p7_main0_bb0_3 $M.0_bb0_3)
        (= $p7_main0_bb0_4 $M.0_bb0_4)
        (= $p7_main0_bb0_5 $M.0_bb0_5)
        (= $p7_main0_bb0_6 $M.0_bb0_6)
        (= $p7_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p8_main0_bb0_0 $p7_main0_bb0_0)
        (= $p8_main0_bb0_1 $p7_main0_bb0_1)
        (= $p8_main0_bb0_2 $p7_main0_bb0_2)
        (= $p8_main0_bb0_3 $p7_main0_bb0_3)
        (= $p8_main0_bb0_4 $p7_main0_bb0_4)
        (= $p8_main0_bb0_5 $p7_main0_bb0_5)
        (= $p8_main0_bb0_6 $p7_main0_bb0_6)
        (= $p8_main0_bb0_7 $p7_main0_bb0_7)
        (= a!1 0)))
 (((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0)) && ($r_main0_bb0 == 0))
 [0m[33m======center test: in spatial translate process======
 [0m[33min emp! emp
 [0m[33m(sep emp)
 [0m[34m(let ((a!1 (+ 0
               (* 1 $r_main0_bb0_0)
               (* (* 1 256) $r_main0_bb0_1)
               (* (* (* 1 256) 256) $r_main0_bb0_2)
               (* (* (* 1 256) 256) 256 $r_main0_bb0_3))))
   (and true
        true
        (= $p1_main0_bb0_0 $p0_main0_bb0_0)
        (= $p1_main0_bb0_1 $p0_main0_bb0_1)
        (= $p1_main0_bb0_2 $p0_main0_bb0_2)
        (= $p1_main0_bb0_3 $p0_main0_bb0_3)
        (= $p1_main0_bb0_4 $p0_main0_bb0_4)
        (= $p1_main0_bb0_5 $p0_main0_bb0_5)
        (= $p1_main0_bb0_6 $p0_main0_bb0_6)
        (= $p1_main0_bb0_7 $p0_main0_bb0_7)
        true
        (= $M.0_bb0_0 $p0_main0_bb0_0)
        (= $M.0_bb0_1 $p0_main0_bb0_1)
        (= $M.0_bb0_2 $p0_main0_bb0_2)
        (= $M.0_bb0_3 $p0_main0_bb0_3)
        (= $M.0_bb0_4 $p0_main0_bb0_4)
        (= $M.0_bb0_5 $p0_main0_bb0_5)
        (= $M.0_bb0_6 $p0_main0_bb0_6)
        (= $M.0_bb0_7 $p0_main0_bb0_7)
        (=> $i3_main0_bb0 $fresh1)
        (=> $fresh1 $i3_main0_bb0)
        true
        (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
        true
        (= $p1_f0_bb0_0 $p0_f0_bb0_0)
        (= $p1_f0_bb0_1 $p0_f0_bb0_1)
        (= $p1_f0_bb0_2 $p0_f0_bb0_2)
        (= $p1_f0_bb0_3 $p0_f0_bb0_3)
        (= $p1_f0_bb0_4 $p0_f0_bb0_4)
        (= $p1_f0_bb0_5 $p0_f0_bb0_5)
        (= $p1_f0_bb0_6 $p0_f0_bb0_6)
        (= $p1_f0_bb0_7 $p0_f0_bb0_7)
        true
        (= $p2_f0_bb0_0 $M.0_bb0_0)
        (= $p2_f0_bb0_1 $M.0_bb0_1)
        (= $p2_f0_bb0_2 $M.0_bb0_2)
        (= $p2_f0_bb0_3 $M.0_bb0_3)
        (= $p2_f0_bb0_4 $M.0_bb0_4)
        (= $p2_f0_bb0_5 $M.0_bb0_5)
        (= $p2_f0_bb0_6 $M.0_bb0_6)
        (= $p2_f0_bb0_7 $M.0_bb0_7)
        true
        (=> $i0_h0_bb0 $fresh4)
        (=> $fresh4 $i0_h0_bb0)
        true
        (not (and (=> $i0_h0_bb0 true) (=> true $i0_h0_bb0)))
        true
        (= $p4_main0_bb0_0 $M.0_bb0_0)
        (= $p4_main0_bb0_1 $M.0_bb0_1)
        (= $p4_main0_bb0_2 $M.0_bb0_2)
        (= $p4_main0_bb0_3 $M.0_bb0_3)
        (= $p4_main0_bb0_4 $M.0_bb0_4)
        (= $p4_main0_bb0_5 $M.0_bb0_5)
        (= $p4_main0_bb0_6 $M.0_bb0_6)
        (= $p4_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p5_main0_bb0_0 0)
        (= $p5_main0_bb0_1 0)
        (= $p5_main0_bb0_2 0)
        (= $p5_main0_bb0_3 0)
        (= $p5_main0_bb0_4 0)
        (= $p5_main0_bb0_5 0)
        (= $p5_main0_bb0_6 0)
        (= $p5_main0_bb0_7 0)
        true
        (= $p6_main0_bb0_0 $p5_main0_bb0_0)
        (= $p6_main0_bb0_1 $p5_main0_bb0_1)
        (= $p6_main0_bb0_2 $p5_main0_bb0_2)
        (= $p6_main0_bb0_3 $p5_main0_bb0_3)
        (= $p6_main0_bb0_4 $p5_main0_bb0_4)
        (= $p6_main0_bb0_5 $p5_main0_bb0_5)
        (= $p6_main0_bb0_6 $p5_main0_bb0_6)
        (= $p6_main0_bb0_7 $p5_main0_bb0_7)
        true
        (= $p7_main0_bb0_0 $M.0_bb0_0)
        (= $p7_main0_bb0_1 $M.0_bb0_1)
        (= $p7_main0_bb0_2 $M.0_bb0_2)
        (= $p7_main0_bb0_3 $M.0_bb0_3)
        (= $p7_main0_bb0_4 $M.0_bb0_4)
        (= $p7_main0_bb0_5 $M.0_bb0_5)
        (= $p7_main0_bb0_6 $M.0_bb0_6)
        (= $p7_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p8_main0_bb0_0 $p7_main0_bb0_0)
        (= $p8_main0_bb0_1 $p7_main0_bb0_1)
        (= $p8_main0_bb0_2 $p7_main0_bb0_2)
        (= $p8_main0_bb0_3 $p7_main0_bb0_3)
        (= $p8_main0_bb0_4 $p7_main0_bb0_4)
        (= $p8_main0_bb0_5 $p7_main0_bb0_5)
        (= $p8_main0_bb0_6 $p7_main0_bb0_6)
        (= $p8_main0_bb0_7 $p7_main0_bb0_7)
        (= a!1 0)
        (sep emp)))
 [0m[34mINFO: Check 
 [0m[34m(let ((a!1 (+ 0
               (* 1 $r_main0_bb0_0)
               (* (* 1 256) $r_main0_bb0_1)
               (* (* (* 1 256) 256) $r_main0_bb0_2)
               (* (* (* 1 256) 256) 256 $r_main0_bb0_3))))
   (and true
        true
        (= $p1_main0_bb0_0 $p0_main0_bb0_0)
        (= $p1_main0_bb0_1 $p0_main0_bb0_1)
        (= $p1_main0_bb0_2 $p0_main0_bb0_2)
        (= $p1_main0_bb0_3 $p0_main0_bb0_3)
        (= $p1_main0_bb0_4 $p0_main0_bb0_4)
        (= $p1_main0_bb0_5 $p0_main0_bb0_5)
        (= $p1_main0_bb0_6 $p0_main0_bb0_6)
        (= $p1_main0_bb0_7 $p0_main0_bb0_7)
        true
        (= $M.0_bb0_0 $p0_main0_bb0_0)
        (= $M.0_bb0_1 $p0_main0_bb0_1)
        (= $M.0_bb0_2 $p0_main0_bb0_2)
        (= $M.0_bb0_3 $p0_main0_bb0_3)
        (= $M.0_bb0_4 $p0_main0_bb0_4)
        (= $M.0_bb0_5 $p0_main0_bb0_5)
        (= $M.0_bb0_6 $p0_main0_bb0_6)
        (= $M.0_bb0_7 $p0_main0_bb0_7)
        (=> $i3_main0_bb0 $fresh1)
        (=> $fresh1 $i3_main0_bb0)
        true
        (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
        true
        (= $p1_f0_bb0_0 $p0_f0_bb0_0)
        (= $p1_f0_bb0_1 $p0_f0_bb0_1)
        (= $p1_f0_bb0_2 $p0_f0_bb0_2)
        (= $p1_f0_bb0_3 $p0_f0_bb0_3)
        (= $p1_f0_bb0_4 $p0_f0_bb0_4)
        (= $p1_f0_bb0_5 $p0_f0_bb0_5)
        (= $p1_f0_bb0_6 $p0_f0_bb0_6)
        (= $p1_f0_bb0_7 $p0_f0_bb0_7)
        true
        (= $p2_f0_bb0_0 $M.0_bb0_0)
        (= $p2_f0_bb0_1 $M.0_bb0_1)
        (= $p2_f0_bb0_2 $M.0_bb0_2)
        (= $p2_f0_bb0_3 $M.0_bb0_3)
        (= $p2_f0_bb0_4 $M.0_bb0_4)
        (= $p2_f0_bb0_5 $M.0_bb0_5)
        (= $p2_f0_bb0_6 $M.0_bb0_6)
        (= $p2_f0_bb0_7 $M.0_bb0_7)
        true
        (=> $i0_h0_bb0 $fresh4)
        (=> $fresh4 $i0_h0_bb0)
        true
        (not (and (=> $i0_h0_bb0 true) (=> true $i0_h0_bb0)))
        true
        (= $p4_main0_bb0_0 $M.0_bb0_0)
        (= $p4_main0_bb0_1 $M.0_bb0_1)
        (= $p4_main0_bb0_2 $M.0_bb0_2)
        (= $p4_main0_bb0_3 $M.0_bb0_3)
        (= $p4_main0_bb0_4 $M.0_bb0_4)
        (= $p4_main0_bb0_5 $M.0_bb0_5)
        (= $p4_main0_bb0_6 $M.0_bb0_6)
        (= $p4_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p5_main0_bb0_0 0)
        (= $p5_main0_bb0_1 0)
        (= $p5_main0_bb0_2 0)
        (= $p5_main0_bb0_3 0)
        (= $p5_main0_bb0_4 0)
        (= $p5_main0_bb0_5 0)
        (= $p5_main0_bb0_6 0)
        (= $p5_main0_bb0_7 0)
        true
        (= $p6_main0_bb0_0 $p5_main0_bb0_0)
        (= $p6_main0_bb0_1 $p5_main0_bb0_1)
        (= $p6_main0_bb0_2 $p5_main0_bb0_2)
        (= $p6_main0_bb0_3 $p5_main0_bb0_3)
        (= $p6_main0_bb0_4 $p5_main0_bb0_4)
        (= $p6_main0_bb0_5 $p5_main0_bb0_5)
        (= $p6_main0_bb0_6 $p5_main0_bb0_6)
        (= $p6_main0_bb0_7 $p5_main0_bb0_7)
        true
        (= $p7_main0_bb0_0 $M.0_bb0_0)
        (= $p7_main0_bb0_1 $M.0_bb0_1)
        (= $p7_main0_bb0_2 $M.0_bb0_2)
        (= $p7_main0_bb0_3 $M.0_bb0_3)
        (= $p7_main0_bb0_4 $M.0_bb0_4)
        (= $p7_main0_bb0_5 $M.0_bb0_5)
        (= $p7_main0_bb0_6 $M.0_bb0_6)
        (= $p7_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p8_main0_bb0_0 $p7_main0_bb0_0)
        (= $p8_main0_bb0_1 $p7_main0_bb0_1)
        (= $p8_main0_bb0_2 $p7_main0_bb0_2)
        (= $p8_main0_bb0_3 $p7_main0_bb0_3)
        (= $p8_main0_bb0_4 $p7_main0_bb0_4)
        (= $p8_main0_bb0_5 $p7_main0_bb0_5)
        (= $p8_main0_bb0_6 $p7_main0_bb0_6)
        (= $p8_main0_bb0_7 $p7_main0_bb0_7)
        (= a!1 0)
        (sep emp)))
 [0m[34m|
 |———— 
 |
 
 [0m[34m(and true emp)
 [0m[32mCHECK: MemLeak Satisfied!
 [0m[32mCHECK: Inference check pass!
 [0m=========== END SYMBOLIC EXECUTION FOR ONE BLOCk
 -----------------END MEMSAFE ANALYSIS---------------
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 SMACK generated ../svcomp/memsafety//global-atexit-5.bpl
SMACK program verifier version 2.6.3
Running clang -c -emit-llvm -O0 -g -gcolumn-info -Xclang -disable-O0-optnone -I/usr/local/share/smack/include -DMEMORY_MODEL_NO_REUSE_IMPLS -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-lia00n12.bc ../svcomp/memsafety//global-atexit-5.c
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-m8jai0pt.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/global-atexit-5-lia00n12.bc
Running llvm-link -o /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-mrnpwrpr.bc /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/a-m8jai0pt.bc
Running llvm2bpl /home/clexma/Desktop/Disk_D/Tools/SMACK/SmackBasedPrj/testcases/benchmark/b-mrnpwrpr.bc -bpl ../svcomp/memsafety//global-atexit-5.bpl -warn-type unsound -sea-dsa=ci -source-loc-syms -entry-points main -ll ../svcomp/memsafety//global-atexit-5_IR.ll -mem-mod-impls -llvm-assumes=none -sh-mem-leak
[regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 -----------------START MEMSAFE ANALYSIS---------------
 Begin verifying
 Adding procedure: free_g1
 Empty block name founded in proc free_g1
 Adding procedure: free_
 Empty block name founded in proc free_
 Adding procedure: free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Empty block name founded in proc free_g2
 Adding procedure: h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Empty block name founded in proc h
 Adding procedure: __VERIFIER_nondet_bool
 Empty blocks of proc __VERIFIER_nondet_bool
 Adding procedure: exit
 Empty blocks of proc exit
 Adding procedure: f
 Empty block name founded in proc f
 Adding procedure: malloc
 Empty block name founded in proc malloc
 Adding procedure: atexit
 Empty blocks of proc atexit
 Adding procedure: main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Empty block name founded in proc main
 Adding procedure: __SMACK_static_init
 Empty block name founded in proc __SMACK_static_init
 Adding procedure: boogie_si_record_i1
 Empty blocks of proc boogie_si_record_i1
 Adding procedure: boogie_si_record_ref
 Empty blocks of proc boogie_si_record_ref
 Adding procedure: $initialize
 Empty block name founded in proc $initialize
 inlining procedure: main
 $bb0_main_0 1 0
 New stmts! 
 call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
 call $p0_main0 := malloc(8);
 $p1_main0 := $bitcast.ref.ref($p0_main0);
 $M.0 := $p0_main0;
 call $i2_main0 := atexit(free_g1_main0);
 call $i3_main0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
 assume true;
 goto $bb1_main_0, $bb2_main_0;
 
 $bb1_main_0 1 0
 New stmts! 
 assume ($i3_main0 == 1);
 call exit(1);
 assume false;
 
 $bb2_main_0 2 1
 New stmts! 
 assume !(($i3_main0 == 1));
 
 New stmts! 
 $p4_main0 := $M.0;
 $p5_main0 := $load.ref($M.1, $p4_main0);
 $p6_main0 := $bitcast.ref.ref($p5_main0);
 call free_($p6_main0);
 $p7_main0 := $M.0;
 $p8_main0 := $bitcast.ref.ref($p7_main0);
 call free_($p8_main0);
 $r_main0 := 0;
 return;
 
 call f();
 inlining procedure: f
 $bb0_f_0 2 1
 New stmts! 
 call $p0_f0 := malloc(4);
 $p1_f0 := $bitcast.ref.ref($p0_f0);
 $p2_f0 := $M.0;
 $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
 call $i3_f0 := atexit(free_g2_f0);
 
 New stmts! 
 return;
 
 call h();
 inlining procedure: h
 $bb0_h_0 1 0
 New stmts! 
 call $i0_h0 := __VERIFIER_nondet_bool();
 call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
 assume true;
 goto $bb1_h_0, $bb2_h_0;
 
 $bb1_h_0 1 0
 New stmts! 
 assume ($i0_h0 == 1);
 call exit(1);
 assume false;
 
 
 Inlining procedure: h 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb2_h_0
 return param of 'call h();': 
 	return to: 
 	Add goto relation: $bb2_f_0 -> $bb1_f_0
 Return block: $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 Return process block: $bb2_f_0:
   goto $bb1_f_0;
 Current block: $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 Pass block: $bb3_f_0:
   goto $bb0_h_0;
 Splitting return block
 
 Inlining procedure: f 0
 arguments: 
 	
 parameter: 
 	
 processing return block $bb1_f_0
 return param of 'call f();': 
 	return to: 
 	Add goto relation: $bb4_main_0 -> $bb3_main_0
 Return block: $bb1_f_0:
   goto $bb4_main_0;
 Return process block: $bb4_main_0:
   goto $bb3_main_0;
 Current block: $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 Pass block: $bb5_main_0:
   goto $bb0_f_0;
 Splitting return block
 =====================CENTER NEW===================
 procedure main()
   returns ($r_main0: i32)
 {
   var $p0_main0: ref8;
   var $p1_main0: ref;
   var $i2_main0: i32;
   var $i3_main0: i1;
   var $p4_main0: ref;
   var $p5_main0: ref32;
   var $p6_main0: ref8;
   var $p7_main0: ref;
   var $p8_main0: ref8;
   var $r_main0: i32;
   var $p0_f0: ref8;
   var $p1_f0: ref32;
   var $p2_f0: ref;
   var $i3_f0: i32;
   var $i0_h0: i1;
 $bb0_main_0:
   call {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);
   call $p0_main0 := malloc(8);
   $p1_main0 := $bitcast.ref.ref($p0_main0);
   $M.0 := $p0_main0;
   call $i2_main0 := atexit(free_g1_main0);
   call $i3_main0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);
   assume true;
   goto $bb1_main_0, $bb2_main_0;
 $bb1_main_0:
   assume ($i3_main0 == 1);
   call exit(1);
   assume false;
 $bb2_main_0:
   assume !(($i3_main0 == 1));
   goto $bb5_main_0;
 $bb4_main_0:
   goto $bb3_main_0;
 $bb5_main_0:
   goto $bb0_f_0;
 $bb3_main_0:
   $p4_main0 := $M.0;
   $p5_main0 := $load.ref($M.1, $p4_main0);
   $p6_main0 := $bitcast.ref.ref($p5_main0);
   call free_($p6_main0);
   $p7_main0 := $M.0;
   $p8_main0 := $bitcast.ref.ref($p7_main0);
   call free_($p8_main0);
   $r_main0 := 0;
   return;
 $bb0_f_0:
   call $p0_f0 := malloc(4);
   $p1_f0 := $bitcast.ref.ref($p0_f0);
   $p2_f0 := $M.0;
   $M.1 := $store.ref($M.1, $p2_f0, $p0_f0);
   call $i3_f0 := atexit(free_g2_f0);
   goto $bb3_f_0;
 $bb2_f_0:
   goto $bb1_f_0;
 $bb3_f_0:
   goto $bb0_h_0;
 $bb1_f_0:
   goto $bb4_main_0;
 $bb0_h_0:
   call $i0_h0 := __VERIFIER_nondet_bool();
   call {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);
   assume true;
   goto $bb1_h_0, $bb2_h_0;
 $bb1_h_0:
   assume ($i0_h0 == 1);
   call exit(1);
   assume false;
 $bb2_h_0:
   assume !(($i0_h0 == 1));
   goto $bb2_f_0;
 }
 =====================CENTER NEW===================
 from bb: $bb0_main_0 to bb: $bb1_main_0 $bb2_main_0 
 from bb: $bb2_main_0 to bb: $bb5_main_0 
 from bb: $bb4_main_0 to bb: $bb3_main_0 
 from bb: $bb5_main_0 to bb: $bb0_f_0 
 from bb: $bb0_f_0 to bb: $bb3_f_0 
 from bb: $bb2_f_0 to bb: $bb1_f_0 
 from bb: $bb3_f_0 to bb: $bb0_h_0 
 from bb: $bb1_f_0 to bb: $bb4_main_0 
 from bb: $bb0_h_0 to bb: $bb1_h_0 $bb2_h_0 
 from bb: $bb2_h_0 to bb: $bb2_f_0 
 In $bb1_main_0
 [0mpop: $bb1_main_0
 [0mpop finished
 [0mIn $bb1_h_0
 [0mpop: $bb1_h_0
 [0mpop finished
 [0mIn $bb3_main_0
 [0mpop: $bb3_main_0
 [0mpop finished
 [0mIn $bb4_main_0
 [0mpop: $bb4_main_0
 [0mpop finished
 [0mIn $bb1_f_0
 [0mpop: $bb1_f_0
 [0mpop finished
 [0mIn $bb2_f_0
 [0mpop: $bb2_f_0
 [0mpop finished
 [0mIn $bb2_h_0
 [0mpop: $bb2_h_0
 [0mpop finished
 [0mIn $bb0_h_0
 [0mpop: $bb0_h_0
 [0mpop finished
 [0mIn $bb3_f_0
 [0mpop: $bb3_f_0
 [0mpop finished
 [0mIn $bb0_f_0
 [0mpop: $bb0_f_0
 [0mpop finished
 [0mIn $bb5_main_0
 [0mpop: $bb5_main_0
 [0mpop finished
 [0mIn $bb2_main_0
 [0mpop: $bb2_main_0
 [0mpop finished
 [0mIn $bb0_main_0
 [0mpop: $bb0_main_0
 [0mpop finished
 [0mVerifying globals
 In pro:$bb0_main_0 1 $bb1_main_0 $bb2_main_0 
 In pro:$bb2_main_0 1 $bb5_main_0 
 In pro:$bb5_main_0 1 $bb0_f_0 
 In pro:$bb0_f_0 1 $bb3_f_0 
 In pro:$bb3_f_0 1 $bb0_h_0 
 In pro:$bb0_h_0 1 $bb1_h_0 $bb2_h_0 
 In pro:$bb2_h_0 1 $bb2_f_0 
 In pro:$bb2_f_0 1 $bb1_f_0 
 In pro:$bb1_f_0 1 $bb4_main_0 
 In pro:$bb4_main_0 1 $bb3_main_0 
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume ($i3_main0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && ($i3_main0_bb0 == 1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall exit(1);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: exit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume false;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && ($i3_main0_bb0 == 1)) && false)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [33m======center test: in pure translate process=======
 [0m[34mtranslating var$p1_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$M.0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[34mtranslating var$fresh1
 [0m[34mtranslating boolvar$fresh1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33m(and true
      true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7)
      true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7)
      (=> $i3_main0_bb0 $fresh1)
      (=> $fresh1 $i3_main0_bb0)
      true
      (=> $i3_main0_bb0 true)
      (=> true $i3_main0_bb0)
      false)
 ((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && ($i3_main0_bb0 == 1)) && false)
 [0m[33m======center test: in spatial translate process======
 [0m[33min emp! emp
 [0m[33msizeptlit
 [0m[34mtranslating var$p0_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn intLint : 8
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33min blk!!! (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7))) (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33m(let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
 (let ((a!3 (+ 0
               (* 1 $p0_main0_bb0_0)
               (* (* 1 256) $p0_main0_bb0_1)
               (* (* (* 1 256) 256) $p0_main0_bb0_2)
               a!1
               (* a!2 $p0_main0_bb0_4)
               (* (* a!2 256) $p0_main0_bb0_5)
               (* (* (* a!2 256) 256) $p0_main0_bb0_6)
               (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7))))
   (sep emp emp (blk a!3 (+ a!3 8)))))
 [0m[32mCHECK: Satisfied, path condition false!
 [0m[32mCHECK: Inference check pass! Path condition unsat...
 [0m=========== END SYMBOLIC EXECUTION FOR ONE BLOCk
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume !(($i3_main0 == 1));[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb5_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_f0 := malloc(4);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 4
 [0m[33mIn intLint : 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p1_f0 := $bitcast.ref.ref($p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap(((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p2_f0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p2_f0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$M.1 := $store.ref($M.1, $p2_f0, $p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs store or load
 [0m[34mSTORE: arg1 $p2_f0 arg2: $p0_f0
 [0m[33mIn intLint : 8
 [0m[34mSTORE: offset 0 Blk size: 8
 [0m[34mINFO: new store offset
 [0m[34mmalloc name: $p0_main0_bb0 splitIndex: 1
 [0m[32mWARNING: VarIntMap get warning. $p0_f0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mStore type: ref Store stepsize: 0
 [0mSymbHeap(((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_f0 := atexit(free_g2_f0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i3_f0_bb0 == $fresh3))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb3_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i0_h0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_h_0, $bb2_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume ($i0_h0 == 1);[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && ($i0_h0_bb0 == 1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall exit(1);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: exit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume false;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && ($i0_h0_bb0 == 1)) && false)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [33m======center test: in pure translate process=======
 [0m[34mtranslating var$p1_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$M.0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[34mtranslating var$fresh1
 [0m[34mtranslating boolvar$fresh1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p1_f0_bb0
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_f0_bb0_0 $p0_f0_bb0_0)
      (= $p1_f0_bb0_1 $p0_f0_bb0_1)
      (= $p1_f0_bb0_2 $p0_f0_bb0_2)
      (= $p1_f0_bb0_3 $p0_f0_bb0_3)
      (= $p1_f0_bb0_4 $p0_f0_bb0_4)
      (= $p1_f0_bb0_5 $p0_f0_bb0_5)
      (= $p1_f0_bb0_6 $p0_f0_bb0_6)
      (= $p1_f0_bb0_7 $p0_f0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p2_f0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p2_f0_bb0_0 $M.0_bb0_0)
      (= $p2_f0_bb0_1 $M.0_bb0_1)
      (= $p2_f0_bb0_2 $M.0_bb0_2)
      (= $p2_f0_bb0_3 $M.0_bb0_3)
      (= $p2_f0_bb0_4 $M.0_bb0_4)
      (= $p2_f0_bb0_5 $M.0_bb0_5)
      (= $p2_f0_bb0_6 $M.0_bb0_6)
      (= $p2_f0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$fresh2
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: true
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[34mtranslating var$fresh4
 [0m[34mtranslating boolvar$fresh4
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33m(and true
      true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7)
      true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7)
      (=> $i3_main0_bb0 $fresh1)
      (=> $fresh1 $i3_main0_bb0)
      true
      (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
      true
      (= $p1_f0_bb0_0 $p0_f0_bb0_0)
      (= $p1_f0_bb0_1 $p0_f0_bb0_1)
      (= $p1_f0_bb0_2 $p0_f0_bb0_2)
      (= $p1_f0_bb0_3 $p0_f0_bb0_3)
      (= $p1_f0_bb0_4 $p0_f0_bb0_4)
      (= $p1_f0_bb0_5 $p0_f0_bb0_5)
      (= $p1_f0_bb0_6 $p0_f0_bb0_6)
      (= $p1_f0_bb0_7 $p0_f0_bb0_7)
      true
      (= $p2_f0_bb0_0 $M.0_bb0_0)
      (= $p2_f0_bb0_1 $M.0_bb0_1)
      (= $p2_f0_bb0_2 $M.0_bb0_2)
      (= $p2_f0_bb0_3 $M.0_bb0_3)
      (= $p2_f0_bb0_4 $M.0_bb0_4)
      (= $p2_f0_bb0_5 $M.0_bb0_5)
      (= $p2_f0_bb0_6 $M.0_bb0_6)
      (= $p2_f0_bb0_7 $M.0_bb0_7)
      true
      (=> $i0_h0_bb0 $fresh4)
      (=> $fresh4 $i0_h0_bb0)
      true
      (=> $i0_h0_bb0 true)
      (=> true $i0_h0_bb0)
      false)
 ((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && ($i0_h0_bb0 == 1)) && false)
 [0m[33m======center test: in spatial translate process======
 [0m[33min emp! emp
 [0m[33msizeptlit
 [0m[33min ptlit!emp
 [0m[34mtranslating var$p2_f0_bb0
 [0m[33mIn intLint : 0
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p2_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p2_f0_bb0_0)
      (* (* 1 256) $p2_f0_bb0_1)
      (* (* (* 1 256) 256) $p2_f0_bb0_2)
      a!1
      (* a!2 $p2_f0_bb0_4)
      (* (* a!2 256) $p2_f0_bb0_5)
      (* (* (* a!2 256) 256) $p2_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p2_f0_bb0_7)
      0))
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn intLint : 8
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33min blk!!! (let ((a!1 (* (* (* (* 1 256) 256) 256) $p2_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p2_f0_bb0_0)
      (* (* 1 256) $p2_f0_bb0_1)
      (* (* (* 1 256) 256) $p2_f0_bb0_2)
      a!1
      (* a!2 $p2_f0_bb0_4)
      (* (* a!2 256) $p2_f0_bb0_5)
      (* (* (* a!2 256) 256) $p2_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p2_f0_bb0_7)
      0)) (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_main0_bb0_0)
      (* (* 1 256) $p0_main0_bb0_1)
      (* (* (* 1 256) 256) $p0_main0_bb0_2)
      a!1
      (* a!2 $p0_main0_bb0_4)
      (* (* a!2 256) $p0_main0_bb0_5)
      (* (* (* a!2 256) 256) $p0_main0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_main0_bb0_7)
      8))
 [0m[33msizeptlit
 [0m[34mtranslating var$p0_f0_bb0
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn intLint : 4
 [0m[33mIn binExpr function!
 [0m[33min plus func!: (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_f0_bb0_0)
      (* (* 1 256) $p0_f0_bb0_1)
      (* (* (* 1 256) 256) $p0_f0_bb0_2)
      a!1
      (* a!2 $p0_f0_bb0_4)
      (* (* a!2 256) $p0_f0_bb0_5)
      (* (* (* a!2 256) 256) $p0_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_f0_bb0_7)
      4))
 [0m[33min blk!!! (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_f0_bb0_0)
      (* (* 1 256) $p0_f0_bb0_1)
      (* (* (* 1 256) 256) $p0_f0_bb0_2)
      a!1
      (* a!2 $p0_f0_bb0_4)
      (* (* a!2 256) $p0_f0_bb0_5)
      (* (* (* a!2 256) 256) $p0_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_f0_bb0_7))) (let ((a!1 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256)))
   (+ 0
      (* 1 $p0_f0_bb0_0)
      (* (* 1 256) $p0_f0_bb0_1)
      (* (* (* 1 256) 256) $p0_f0_bb0_2)
      a!1
      (* a!2 $p0_f0_bb0_4)
      (* (* a!2 256) $p0_f0_bb0_5)
      (* (* (* a!2 256) 256) $p0_f0_bb0_6)
      (* (* (* a!2 256) 256) 256 $p0_f0_bb0_7)
      4))
 [0m[33m(let ((a!1 (* (* (* (* 1 256) 256) 256) $p2_f0_bb0_3))
       (a!2 (* (* (* (* 1 256) 256) 256) 256))
       (a!5 (* (* (* (* 1 256) 256) 256) $p0_main0_bb0_3))
       (a!8 (* (* (* (* 1 256) 256) 256) $p0_f0_bb0_3)))
 (let ((a!3 (* (* (* (* a!2 256) 256) 256) $p2_f0_bb0_7))
       (a!6 (* (* (* (* a!2 256) 256) 256) $p0_main0_bb0_7))
       (a!9 (* (* (* (* a!2 256) 256) 256) $p0_f0_bb0_7)))
 (let ((a!4 (+ 0
               (* 1 $p2_f0_bb0_0)
               (* (* 1 256) $p2_f0_bb0_1)
               (* (* (* 1 256) 256) $p2_f0_bb0_2)
               a!1
               (* a!2 $p2_f0_bb0_4)
               (* (* a!2 256) $p2_f0_bb0_5)
               (* (* (* a!2 256) 256) $p2_f0_bb0_6)
               a!3
               0))
       (a!7 (+ 0
               (* 1 $p0_main0_bb0_0)
               (* (* 1 256) $p0_main0_bb0_1)
               (* (* (* 1 256) 256) $p0_main0_bb0_2)
               a!5
               (* a!2 $p0_main0_bb0_4)
               (* (* a!2 256) $p0_main0_bb0_5)
               (* (* (* a!2 256) 256) $p0_main0_bb0_6)
               a!6
               8))
       (a!10 (+ 0
                (* 1 $p0_f0_bb0_0)
                (* (* 1 256) $p0_f0_bb0_1)
                (* (* (* 1 256) 256) $p0_f0_bb0_2)
                a!8
                (* a!2 $p0_f0_bb0_4)
                (* (* a!2 256) $p0_f0_bb0_5)
                (* (* (* a!2 256) 256) $p0_f0_bb0_6)
                a!9)))
   (sep emp emp emp emp (blk a!4 a!7) emp (blk a!10 (+ a!10 4))))))
 [0m[32mCHECK: Satisfied, path condition false!
 [0m[32mCHECK: Inference check pass! Path condition unsat...
 [0m=========== END SYMBOLIC EXECUTION FOR ONE BLOCk
 =========== DO SYMBOLIC EXECUTION FOR ONE PATH
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:entry:main"} boogie_si_record_ref(main_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_ref
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_main0 := malloc(8);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 8
 [0m[33mIn intLint : 8
 [0mSymbHeap(true|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p1_main0 := $bitcast.ref.ref($p0_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap((true && ($p1_main0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$M.0 := $p0_main0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$p0_main0 $M.0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $p0_main0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i2_main0 := atexit(free_g1_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i2_main0_bb0 == $fresh0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_main0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i3_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_main_0, $bb2_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume !(($i3_main0 == 1));[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb5_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $p0_f0 := malloc(4);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[33mIn intLint : 4
 [0m[33mIn intLint : 4
 [0mSymbHeap((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p1_f0 := $bitcast.ref.ref($p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap(((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p2_f0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p2_f0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$M.1 := $store.ref($M.1, $p2_f0, $p0_f0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs store or load
 [0m[34mSTORE: arg1 $p2_f0 arg2: $p0_f0
 [0m[33mIn intLint : 8
 [0m[34mSTORE: offset 0 Blk size: 8
 [0m[34mINFO: new store offset
 [0m[34mmalloc name: $p0_main0_bb0 splitIndex: 1
 [0m[32mWARNING: VarIntMap get warning. $p0_f0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mStore type: ref Store stepsize: 0
 [0mSymbHeap(((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i3_f0 := atexit(free_g2_f0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute Unintepreted function. atexit
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i3_f0_bb0 == $fresh3))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [34mINFO: UNsolved proc call: atexit
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb3_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb0_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall $i0_h0 := __VERIFIER_nondet_bool();[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: execute VERIFIER Call.
 [0mSymbHeap((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall {:cexpr "smack:ext:__VERIFIER_nondet_bool"} boogie_si_record_i1($i0_h0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mINFO: UNsolved proc call: boogie_si_record_i1
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume true;[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 2
 [0mSymbHeap(((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true)|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_h_0, $bb2_h_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0massume !(($i0_h0 == 1));[34m
 [0m[34mINFO: stmt kind ASSUME
 [0m[34mINFO: Basic Parse condition, 4
 [0mSymbHeap((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1)))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb2_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb1_f_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb4_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mgoto $bb3_main_0;[34m
 [0m[34mINFO: stmt kind 5
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p4_main0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p4_main0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap(((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p5_main0 := $load.ref($M.1, $p4_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs store or load
 [0m[34mINFO: Load $p4_main0_bb0 to $p5_main0_bb0
 [0m[33mIn intLint : 8
 [0m[34mloadPosResult: 1 1
 [0m[34mINFO: loaded expr: $fresh2
 [0m[32mWARNING: VarIntMap link error. Newname: 0 OldName: 0 $p5_main0_bb0 $fresh2
 [0mSymbHeap((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p6_main0 := $bitcast.ref.ref($p5_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0m[32mERROR: VarEquiv blkoffset no name exists. 
 [0mSymbHeap(((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)) # $p0_f0_bb0 >-s-> 4 # Blk($p0_f0_bb0, ($p0_f0_bb0 + 4)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall free_($p6_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mFreed varname: $p6_main0_bb0
 [0m[34mAlloced varname: $p0_f0_bb0
 [0m[34mLinked Name: $p0_f0_bb0
 [0mSymbHeap(((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m$p0_f0_bb0 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p7_main0 := $M.0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr$M.0 $p7_main0
 [0m[34mINFO: RHS is Var
 [0m[32mWARNING: VarIntMap get warning. $M.0_bb0
 [0m[33min varExpr! 0 0
 [0m[34mINFO: cannot compute int value..
 [0mSymbHeap((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)))
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m$p0_f0_bb0 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$p8_main0 := $bitcast.ref.ref($p7_main0);[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mASSIGN: rhs ExprType::FUNC
 [0m[34mASSIGN: rhs Unary ptr cast
 [0m[34mArg1 Type: 13
 [0mSymbHeap(((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0))|emp # $p0_main0_bb0 >-s-> 8 # Blk($p0_main0_bb0, $p2_f0_bb0) # $p2_f0_bb0 >--> $fresh2 # Blk(($p2_f0_bb0 + 0), ($p0_main0_bb0 + 8)))[34m
 [0m[32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mKey: $p8_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m$p0_f0_bb0 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mcall free_($p8_main0);[34m
 [0m[34mINFO: stmt kind CALL
 [0m[34mFreed varname: $p8_main0_bb0
 [0m[34mAlloced varname: $p0_main0_bb0
 [0m[34mLinked Name: $p0_main0_bb0
 [0mSymbHeap(((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0))|emp)
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mKey: $p8_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m$p0_f0_bb0 [0m[32m$p0_main0_bb0 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0m$r_main0 := 0;[34m
 [0m[34mINFO: stmt kind ASSIGN
 [0m[34mINFO: ASSIGN RHS is not a funcExpr0 $r_main0
 [0m[33mIn intLint : 0
 [0mSymbHeap((((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0)) && ($r_main0_bb0 == 0))|emp)
 [32mDebug VarEquiv: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh0| Var: $fresh0
 [0m[32mKey: $fresh1| Var: $fresh1
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $fresh3| Var: $fresh3
 [0m[32mKey: $fresh4| Var: $fresh4
 [0m[32mKey: $i0_h0_bb0| Var: $fresh4
 [0m[32mKey: $i2_main0_bb0| Var: $fresh0
 [0m[32mKey: $i3_f0_bb0| Var: $fresh3
 [0m[32mKey: $i3_main0_bb0| Var: $fresh1
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $r_main0_bb0| Var: $r_main0_bb0
 [0m[32mDebug BlkLinkName: 
 [0m[32mKey: $M.0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $Null| Var: $Null
 [0m[32mKey: $fresh2| Var: $p0_f0_bb0
 [0m[32mKey: $p0_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p0_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p1_f0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p1_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p2_f0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p4_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p5_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p6_main0_bb0| Var: $p0_f0_bb0
 [0m[32mKey: $p7_main0_bb0| Var: $p0_main0_bb0
 [0m[32mKey: $p8_main0_bb0| Var: $p0_main0_bb0
 [0m[32mDebug Offset:
 [0m[32mKey: $M.0_bb0| Var: 0
 [0m[32mKey: $Null| Var: 0
 [0m[32mKey: $p0_f0_bb0| Var: 0
 [0m[32mKey: $p0_main0_bb0| Var: 0
 [0m[32mKey: $p1_f0_bb0| Var: 0
 [0m[32mKey: $p1_main0_bb0| Var: 0
 [0m[32mKey: $p2_f0_bb0| Var: 0
 [0m[32mKey: $p4_main0_bb0| Var: 0
 [0m[32mKey: $p7_main0_bb0| Var: 0
 [0m[32mKey: $p8_main0_bb0| Var: 0
 [0m[32mDebug IntVal: 
 [0m[32mKey: $Null| Val: 0
 [0m[32mKey: $r_main0_bb0| Val: 0
 [0m[32mDebug freedBlkName: 
 [0m[32m$p0_f0_bb0 [0m[32m$p0_main0_bb0 [0m[32m
 [0m[34mINFO: executing for stmt: 
 [0mreturn;[34m
 [0m[34mINFO: stmt kind 7
 [0m[33m======center test: in pure translate process=======
 [0m[34mtranslating var$p1_main0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_main0_bb0_0 $p0_main0_bb0_0)
      (= $p1_main0_bb0_1 $p0_main0_bb0_1)
      (= $p1_main0_bb0_2 $p0_main0_bb0_2)
      (= $p1_main0_bb0_3 $p0_main0_bb0_3)
      (= $p1_main0_bb0_4 $p0_main0_bb0_4)
      (= $p1_main0_bb0_5 $p0_main0_bb0_5)
      (= $p1_main0_bb0_6 $p0_main0_bb0_6)
      (= $p1_main0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$M.0_bb0
 [0m[34mtranslating var$p0_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $M.0_bb0_0 $p0_main0_bb0_0)
      (= $M.0_bb0_1 $p0_main0_bb0_1)
      (= $M.0_bb0_2 $p0_main0_bb0_2)
      (= $M.0_bb0_3 $p0_main0_bb0_3)
      (= $M.0_bb0_4 $p0_main0_bb0_4)
      (= $M.0_bb0_5 $p0_main0_bb0_5)
      (= $M.0_bb0_6 $p0_main0_bb0_6)
      (= $M.0_bb0_7 $p0_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[34mtranslating var$fresh1
 [0m[34mtranslating boolvar$fresh1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i3_main0_bb0
 [0m[34mtranslating boolvar$i3_main0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p1_f0_bb0
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p1_f0_bb0_0 $p0_f0_bb0_0)
      (= $p1_f0_bb0_1 $p0_f0_bb0_1)
      (= $p1_f0_bb0_2 $p0_f0_bb0_2)
      (= $p1_f0_bb0_3 $p0_f0_bb0_3)
      (= $p1_f0_bb0_4 $p0_f0_bb0_4)
      (= $p1_f0_bb0_5 $p0_f0_bb0_5)
      (= $p1_f0_bb0_6 $p0_f0_bb0_6)
      (= $p1_f0_bb0_7 $p0_f0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p2_f0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p2_f0_bb0_0 $M.0_bb0_0)
      (= $p2_f0_bb0_1 $M.0_bb0_1)
      (= $p2_f0_bb0_2 $M.0_bb0_2)
      (= $p2_f0_bb0_3 $M.0_bb0_3)
      (= $p2_f0_bb0_4 $M.0_bb0_4)
      (= $p2_f0_bb0_5 $M.0_bb0_5)
      (= $p2_f0_bb0_6 $M.0_bb0_6)
      (= $p2_f0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$fresh2
 [0m[34mtranslating var$p0_f0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: true
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[34mtranslating var$fresh4
 [0m[34mtranslating boolvar$fresh4
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$i0_h0_bb0
 [0m[34mtranslating boolvar$i0_h0_bb0
 [0m[33mIn intLint : 1
 [0m[33mIn binExpr function!
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p4_main0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p4_main0_bb0_0 $M.0_bb0_0)
      (= $p4_main0_bb0_1 $M.0_bb0_1)
      (= $p4_main0_bb0_2 $M.0_bb0_2)
      (= $p4_main0_bb0_3 $M.0_bb0_3)
      (= $p4_main0_bb0_4 $M.0_bb0_4)
      (= $p4_main0_bb0_5 $M.0_bb0_5)
      (= $p4_main0_bb0_6 $M.0_bb0_6)
      (= $p4_main0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p5_main0_bb0
 [0m[34mtranslating var$fresh2
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p5_main0_bb0_0 0)
      (= $p5_main0_bb0_1 0)
      (= $p5_main0_bb0_2 0)
      (= $p5_main0_bb0_3 0)
      (= $p5_main0_bb0_4 0)
      (= $p5_main0_bb0_5 0)
      (= $p5_main0_bb0_6 0)
      (= $p5_main0_bb0_7 0))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p6_main0_bb0
 [0m[34mtranslating var$p5_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p6_main0_bb0_0 $p5_main0_bb0_0)
      (= $p6_main0_bb0_1 $p5_main0_bb0_1)
      (= $p6_main0_bb0_2 $p5_main0_bb0_2)
      (= $p6_main0_bb0_3 $p5_main0_bb0_3)
      (= $p6_main0_bb0_4 $p5_main0_bb0_4)
      (= $p6_main0_bb0_5 $p5_main0_bb0_5)
      (= $p6_main0_bb0_6 $p5_main0_bb0_6)
      (= $p6_main0_bb0_7 $p5_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p7_main0_bb0
 [0m[34mtranslating var$M.0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p7_main0_bb0_0 $M.0_bb0_0)
      (= $p7_main0_bb0_1 $M.0_bb0_1)
      (= $p7_main0_bb0_2 $M.0_bb0_2)
      (= $p7_main0_bb0_3 $M.0_bb0_3)
      (= $p7_main0_bb0_4 $M.0_bb0_4)
      (= $p7_main0_bb0_5 $M.0_bb0_5)
      (= $p7_main0_bb0_6 $M.0_bb0_6)
      (= $p7_main0_bb0_7 $M.0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$p8_main0_bb0
 [0m[34mtranslating var$p7_main0_bb0
 [0m[33mIn binExpr function!
 [0m[33min eq func!: (and true
      (= $p8_main0_bb0_0 $p7_main0_bb0_0)
      (= $p8_main0_bb0_1 $p7_main0_bb0_1)
      (= $p8_main0_bb0_2 $p7_main0_bb0_2)
      (= $p8_main0_bb0_3 $p7_main0_bb0_3)
      (= $p8_main0_bb0_4 $p7_main0_bb0_4)
      (= $p8_main0_bb0_5 $p7_main0_bb0_5)
      (= $p8_main0_bb0_6 $p7_main0_bb0_6)
      (= $p8_main0_bb0_7 $p7_main0_bb0_7))
 [0m[33mIn binExpr function!
 [0m[34mtranslating var$r_main0_bb0
 [0m[33mIn intLint : 0
 [0m[33mIn binExpr function!
 [0m[34mWARNING: directly let lhs == rhs ...
 [0m[33mIn binExpr function!
 [0m[33m(let ((a!1 (+ 0
               (* 1 $r_main0_bb0_0)
               (* (* 1 256) $r_main0_bb0_1)
               (* (* (* 1 256) 256) $r_main0_bb0_2)
               (* (* (* 1 256) 256) 256 $r_main0_bb0_3))))
   (and true
        true
        (= $p1_main0_bb0_0 $p0_main0_bb0_0)
        (= $p1_main0_bb0_1 $p0_main0_bb0_1)
        (= $p1_main0_bb0_2 $p0_main0_bb0_2)
        (= $p1_main0_bb0_3 $p0_main0_bb0_3)
        (= $p1_main0_bb0_4 $p0_main0_bb0_4)
        (= $p1_main0_bb0_5 $p0_main0_bb0_5)
        (= $p1_main0_bb0_6 $p0_main0_bb0_6)
        (= $p1_main0_bb0_7 $p0_main0_bb0_7)
        true
        (= $M.0_bb0_0 $p0_main0_bb0_0)
        (= $M.0_bb0_1 $p0_main0_bb0_1)
        (= $M.0_bb0_2 $p0_main0_bb0_2)
        (= $M.0_bb0_3 $p0_main0_bb0_3)
        (= $M.0_bb0_4 $p0_main0_bb0_4)
        (= $M.0_bb0_5 $p0_main0_bb0_5)
        (= $M.0_bb0_6 $p0_main0_bb0_6)
        (= $M.0_bb0_7 $p0_main0_bb0_7)
        (=> $i3_main0_bb0 $fresh1)
        (=> $fresh1 $i3_main0_bb0)
        true
        (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
        true
        (= $p1_f0_bb0_0 $p0_f0_bb0_0)
        (= $p1_f0_bb0_1 $p0_f0_bb0_1)
        (= $p1_f0_bb0_2 $p0_f0_bb0_2)
        (= $p1_f0_bb0_3 $p0_f0_bb0_3)
        (= $p1_f0_bb0_4 $p0_f0_bb0_4)
        (= $p1_f0_bb0_5 $p0_f0_bb0_5)
        (= $p1_f0_bb0_6 $p0_f0_bb0_6)
        (= $p1_f0_bb0_7 $p0_f0_bb0_7)
        true
        (= $p2_f0_bb0_0 $M.0_bb0_0)
        (= $p2_f0_bb0_1 $M.0_bb0_1)
        (= $p2_f0_bb0_2 $M.0_bb0_2)
        (= $p2_f0_bb0_3 $M.0_bb0_3)
        (= $p2_f0_bb0_4 $M.0_bb0_4)
        (= $p2_f0_bb0_5 $M.0_bb0_5)
        (= $p2_f0_bb0_6 $M.0_bb0_6)
        (= $p2_f0_bb0_7 $M.0_bb0_7)
        true
        (=> $i0_h0_bb0 $fresh4)
        (=> $fresh4 $i0_h0_bb0)
        true
        (not (and (=> $i0_h0_bb0 true) (=> true $i0_h0_bb0)))
        true
        (= $p4_main0_bb0_0 $M.0_bb0_0)
        (= $p4_main0_bb0_1 $M.0_bb0_1)
        (= $p4_main0_bb0_2 $M.0_bb0_2)
        (= $p4_main0_bb0_3 $M.0_bb0_3)
        (= $p4_main0_bb0_4 $M.0_bb0_4)
        (= $p4_main0_bb0_5 $M.0_bb0_5)
        (= $p4_main0_bb0_6 $M.0_bb0_6)
        (= $p4_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p5_main0_bb0_0 0)
        (= $p5_main0_bb0_1 0)
        (= $p5_main0_bb0_2 0)
        (= $p5_main0_bb0_3 0)
        (= $p5_main0_bb0_4 0)
        (= $p5_main0_bb0_5 0)
        (= $p5_main0_bb0_6 0)
        (= $p5_main0_bb0_7 0)
        true
        (= $p6_main0_bb0_0 $p5_main0_bb0_0)
        (= $p6_main0_bb0_1 $p5_main0_bb0_1)
        (= $p6_main0_bb0_2 $p5_main0_bb0_2)
        (= $p6_main0_bb0_3 $p5_main0_bb0_3)
        (= $p6_main0_bb0_4 $p5_main0_bb0_4)
        (= $p6_main0_bb0_5 $p5_main0_bb0_5)
        (= $p6_main0_bb0_6 $p5_main0_bb0_6)
        (= $p6_main0_bb0_7 $p5_main0_bb0_7)
        true
        (= $p7_main0_bb0_0 $M.0_bb0_0)
        (= $p7_main0_bb0_1 $M.0_bb0_1)
        (= $p7_main0_bb0_2 $M.0_bb0_2)
        (= $p7_main0_bb0_3 $M.0_bb0_3)
        (= $p7_main0_bb0_4 $M.0_bb0_4)
        (= $p7_main0_bb0_5 $M.0_bb0_5)
        (= $p7_main0_bb0_6 $M.0_bb0_6)
        (= $p7_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p8_main0_bb0_0 $p7_main0_bb0_0)
        (= $p8_main0_bb0_1 $p7_main0_bb0_1)
        (= $p8_main0_bb0_2 $p7_main0_bb0_2)
        (= $p8_main0_bb0_3 $p7_main0_bb0_3)
        (= $p8_main0_bb0_4 $p7_main0_bb0_4)
        (= $p8_main0_bb0_5 $p7_main0_bb0_5)
        (= $p8_main0_bb0_6 $p7_main0_bb0_6)
        (= $p8_main0_bb0_7 $p7_main0_bb0_7)
        (= a!1 0)))
 (((((((((((((((((true && ($p1_main0_bb0 == $p0_main0_bb0)) && ($M.0_bb0 == $p0_main0_bb0)) && ($i3_main0_bb0 == $fresh1)) && true) && !(($i3_main0_bb0 == 1))) && ($p1_f0_bb0 == $p0_f0_bb0)) && ($p2_f0_bb0 == $M.0_bb0)) && ($fresh2 == $p0_f0_bb0)) && ($i0_h0_bb0 == $fresh4)) && true) && !(($i0_h0_bb0 == 1))) && ($p4_main0_bb0 == $M.0_bb0)) && ($p5_main0_bb0 == $fresh2)) && ($p6_main0_bb0 == $p5_main0_bb0)) && ($p7_main0_bb0 == $M.0_bb0)) && ($p8_main0_bb0 == $p7_main0_bb0)) && ($r_main0_bb0 == 0))
 [0m[33m======center test: in spatial translate process======
 [0m[33min emp! emp
 [0m[33m(sep emp)
 [0m[34m(let ((a!1 (+ 0
               (* 1 $r_main0_bb0_0)
               (* (* 1 256) $r_main0_bb0_1)
               (* (* (* 1 256) 256) $r_main0_bb0_2)
               (* (* (* 1 256) 256) 256 $r_main0_bb0_3))))
   (and true
        true
        (= $p1_main0_bb0_0 $p0_main0_bb0_0)
        (= $p1_main0_bb0_1 $p0_main0_bb0_1)
        (= $p1_main0_bb0_2 $p0_main0_bb0_2)
        (= $p1_main0_bb0_3 $p0_main0_bb0_3)
        (= $p1_main0_bb0_4 $p0_main0_bb0_4)
        (= $p1_main0_bb0_5 $p0_main0_bb0_5)
        (= $p1_main0_bb0_6 $p0_main0_bb0_6)
        (= $p1_main0_bb0_7 $p0_main0_bb0_7)
        true
        (= $M.0_bb0_0 $p0_main0_bb0_0)
        (= $M.0_bb0_1 $p0_main0_bb0_1)
        (= $M.0_bb0_2 $p0_main0_bb0_2)
        (= $M.0_bb0_3 $p0_main0_bb0_3)
        (= $M.0_bb0_4 $p0_main0_bb0_4)
        (= $M.0_bb0_5 $p0_main0_bb0_5)
        (= $M.0_bb0_6 $p0_main0_bb0_6)
        (= $M.0_bb0_7 $p0_main0_bb0_7)
        (=> $i3_main0_bb0 $fresh1)
        (=> $fresh1 $i3_main0_bb0)
        true
        (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
        true
        (= $p1_f0_bb0_0 $p0_f0_bb0_0)
        (= $p1_f0_bb0_1 $p0_f0_bb0_1)
        (= $p1_f0_bb0_2 $p0_f0_bb0_2)
        (= $p1_f0_bb0_3 $p0_f0_bb0_3)
        (= $p1_f0_bb0_4 $p0_f0_bb0_4)
        (= $p1_f0_bb0_5 $p0_f0_bb0_5)
        (= $p1_f0_bb0_6 $p0_f0_bb0_6)
        (= $p1_f0_bb0_7 $p0_f0_bb0_7)
        true
        (= $p2_f0_bb0_0 $M.0_bb0_0)
        (= $p2_f0_bb0_1 $M.0_bb0_1)
        (= $p2_f0_bb0_2 $M.0_bb0_2)
        (= $p2_f0_bb0_3 $M.0_bb0_3)
        (= $p2_f0_bb0_4 $M.0_bb0_4)
        (= $p2_f0_bb0_5 $M.0_bb0_5)
        (= $p2_f0_bb0_6 $M.0_bb0_6)
        (= $p2_f0_bb0_7 $M.0_bb0_7)
        true
        (=> $i0_h0_bb0 $fresh4)
        (=> $fresh4 $i0_h0_bb0)
        true
        (not (and (=> $i0_h0_bb0 true) (=> true $i0_h0_bb0)))
        true
        (= $p4_main0_bb0_0 $M.0_bb0_0)
        (= $p4_main0_bb0_1 $M.0_bb0_1)
        (= $p4_main0_bb0_2 $M.0_bb0_2)
        (= $p4_main0_bb0_3 $M.0_bb0_3)
        (= $p4_main0_bb0_4 $M.0_bb0_4)
        (= $p4_main0_bb0_5 $M.0_bb0_5)
        (= $p4_main0_bb0_6 $M.0_bb0_6)
        (= $p4_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p5_main0_bb0_0 0)
        (= $p5_main0_bb0_1 0)
        (= $p5_main0_bb0_2 0)
        (= $p5_main0_bb0_3 0)
        (= $p5_main0_bb0_4 0)
        (= $p5_main0_bb0_5 0)
        (= $p5_main0_bb0_6 0)
        (= $p5_main0_bb0_7 0)
        true
        (= $p6_main0_bb0_0 $p5_main0_bb0_0)
        (= $p6_main0_bb0_1 $p5_main0_bb0_1)
        (= $p6_main0_bb0_2 $p5_main0_bb0_2)
        (= $p6_main0_bb0_3 $p5_main0_bb0_3)
        (= $p6_main0_bb0_4 $p5_main0_bb0_4)
        (= $p6_main0_bb0_5 $p5_main0_bb0_5)
        (= $p6_main0_bb0_6 $p5_main0_bb0_6)
        (= $p6_main0_bb0_7 $p5_main0_bb0_7)
        true
        (= $p7_main0_bb0_0 $M.0_bb0_0)
        (= $p7_main0_bb0_1 $M.0_bb0_1)
        (= $p7_main0_bb0_2 $M.0_bb0_2)
        (= $p7_main0_bb0_3 $M.0_bb0_3)
        (= $p7_main0_bb0_4 $M.0_bb0_4)
        (= $p7_main0_bb0_5 $M.0_bb0_5)
        (= $p7_main0_bb0_6 $M.0_bb0_6)
        (= $p7_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p8_main0_bb0_0 $p7_main0_bb0_0)
        (= $p8_main0_bb0_1 $p7_main0_bb0_1)
        (= $p8_main0_bb0_2 $p7_main0_bb0_2)
        (= $p8_main0_bb0_3 $p7_main0_bb0_3)
        (= $p8_main0_bb0_4 $p7_main0_bb0_4)
        (= $p8_main0_bb0_5 $p7_main0_bb0_5)
        (= $p8_main0_bb0_6 $p7_main0_bb0_6)
        (= $p8_main0_bb0_7 $p7_main0_bb0_7)
        (= a!1 0)
        (sep emp)))
 [0m[34mINFO: Check 
 [0m[34m(let ((a!1 (+ 0
               (* 1 $r_main0_bb0_0)
               (* (* 1 256) $r_main0_bb0_1)
               (* (* (* 1 256) 256) $r_main0_bb0_2)
               (* (* (* 1 256) 256) 256 $r_main0_bb0_3))))
   (and true
        true
        (= $p1_main0_bb0_0 $p0_main0_bb0_0)
        (= $p1_main0_bb0_1 $p0_main0_bb0_1)
        (= $p1_main0_bb0_2 $p0_main0_bb0_2)
        (= $p1_main0_bb0_3 $p0_main0_bb0_3)
        (= $p1_main0_bb0_4 $p0_main0_bb0_4)
        (= $p1_main0_bb0_5 $p0_main0_bb0_5)
        (= $p1_main0_bb0_6 $p0_main0_bb0_6)
        (= $p1_main0_bb0_7 $p0_main0_bb0_7)
        true
        (= $M.0_bb0_0 $p0_main0_bb0_0)
        (= $M.0_bb0_1 $p0_main0_bb0_1)
        (= $M.0_bb0_2 $p0_main0_bb0_2)
        (= $M.0_bb0_3 $p0_main0_bb0_3)
        (= $M.0_bb0_4 $p0_main0_bb0_4)
        (= $M.0_bb0_5 $p0_main0_bb0_5)
        (= $M.0_bb0_6 $p0_main0_bb0_6)
        (= $M.0_bb0_7 $p0_main0_bb0_7)
        (=> $i3_main0_bb0 $fresh1)
        (=> $fresh1 $i3_main0_bb0)
        true
        (not (and (=> $i3_main0_bb0 true) (=> true $i3_main0_bb0)))
        true
        (= $p1_f0_bb0_0 $p0_f0_bb0_0)
        (= $p1_f0_bb0_1 $p0_f0_bb0_1)
        (= $p1_f0_bb0_2 $p0_f0_bb0_2)
        (= $p1_f0_bb0_3 $p0_f0_bb0_3)
        (= $p1_f0_bb0_4 $p0_f0_bb0_4)
        (= $p1_f0_bb0_5 $p0_f0_bb0_5)
        (= $p1_f0_bb0_6 $p0_f0_bb0_6)
        (= $p1_f0_bb0_7 $p0_f0_bb0_7)
        true
        (= $p2_f0_bb0_0 $M.0_bb0_0)
        (= $p2_f0_bb0_1 $M.0_bb0_1)
        (= $p2_f0_bb0_2 $M.0_bb0_2)
        (= $p2_f0_bb0_3 $M.0_bb0_3)
        (= $p2_f0_bb0_4 $M.0_bb0_4)
        (= $p2_f0_bb0_5 $M.0_bb0_5)
        (= $p2_f0_bb0_6 $M.0_bb0_6)
        (= $p2_f0_bb0_7 $M.0_bb0_7)
        true
        (=> $i0_h0_bb0 $fresh4)
        (=> $fresh4 $i0_h0_bb0)
        true
        (not (and (=> $i0_h0_bb0 true) (=> true $i0_h0_bb0)))
        true
        (= $p4_main0_bb0_0 $M.0_bb0_0)
        (= $p4_main0_bb0_1 $M.0_bb0_1)
        (= $p4_main0_bb0_2 $M.0_bb0_2)
        (= $p4_main0_bb0_3 $M.0_bb0_3)
        (= $p4_main0_bb0_4 $M.0_bb0_4)
        (= $p4_main0_bb0_5 $M.0_bb0_5)
        (= $p4_main0_bb0_6 $M.0_bb0_6)
        (= $p4_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p5_main0_bb0_0 0)
        (= $p5_main0_bb0_1 0)
        (= $p5_main0_bb0_2 0)
        (= $p5_main0_bb0_3 0)
        (= $p5_main0_bb0_4 0)
        (= $p5_main0_bb0_5 0)
        (= $p5_main0_bb0_6 0)
        (= $p5_main0_bb0_7 0)
        true
        (= $p6_main0_bb0_0 $p5_main0_bb0_0)
        (= $p6_main0_bb0_1 $p5_main0_bb0_1)
        (= $p6_main0_bb0_2 $p5_main0_bb0_2)
        (= $p6_main0_bb0_3 $p5_main0_bb0_3)
        (= $p6_main0_bb0_4 $p5_main0_bb0_4)
        (= $p6_main0_bb0_5 $p5_main0_bb0_5)
        (= $p6_main0_bb0_6 $p5_main0_bb0_6)
        (= $p6_main0_bb0_7 $p5_main0_bb0_7)
        true
        (= $p7_main0_bb0_0 $M.0_bb0_0)
        (= $p7_main0_bb0_1 $M.0_bb0_1)
        (= $p7_main0_bb0_2 $M.0_bb0_2)
        (= $p7_main0_bb0_3 $M.0_bb0_3)
        (= $p7_main0_bb0_4 $M.0_bb0_4)
        (= $p7_main0_bb0_5 $M.0_bb0_5)
        (= $p7_main0_bb0_6 $M.0_bb0_6)
        (= $p7_main0_bb0_7 $M.0_bb0_7)
        true
        (= $p8_main0_bb0_0 $p7_main0_bb0_0)
        (= $p8_main0_bb0_1 $p7_main0_bb0_1)
        (= $p8_main0_bb0_2 $p7_main0_bb0_2)
        (= $p8_main0_bb0_3 $p7_main0_bb0_3)
        (= $p8_main0_bb0_4 $p7_main0_bb0_4)
        (= $p8_main0_bb0_5 $p7_main0_bb0_5)
        (= $p8_main0_bb0_6 $p7_main0_bb0_6)
        (= $p8_main0_bb0_7 $p7_main0_bb0_7)
        (= a!1 0)
        (sep emp)))
 [0m[34m|
 |———— 
 |
 
 [0m[34m(and true emp)
 [0m[32mCHECK: MemLeak Satisfied!
 [0m[32mCHECK: Inference check pass!
 [0m=========== END SYMBOLIC EXECUTION FOR ONE BLOCk
 -----------------END MEMSAFE ANALYSIS---------------
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 We are now translating the program to boogie...
 Analyzing globals...
 -------INSERT: Global Variables g
 Analyzing functions...
 Analyzing function: free_g1
 -------INSERT: Global Variables free_g1
 Analyzing function body: free_g1
 Generating body for free_g1
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: free_g1
 
 Analyzing function: free_
 -------INSERT: Global Variables free_
 Analyzing function: free_g2
 -------INSERT: Global Variables free_g2
 Analyzing function body: free_g2
 Generating body for free_g2
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCmp
 visitBranch
 visitBasicBlock
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %4 = load i32**, i32*** @g, align 8, !dbg !24, !verifier.code !21
   in function: free_g2
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: free_g2
 
 Analyzing function: h
 -------INSERT: Global Variables h
 Analyzing function body: h
 Generating body for h
 visitBasicBlock
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitReturn
 
 Finished analyzing function: h
 
 Analyzing function: __VERIFIER_nondet_bool
 -------INSERT: Global Variables __VERIFIER_nondet_bool
 Analyzing function: exit
 -------INSERT: Global Variables exit
 Analyzing function: f
 -------INSERT: Global Variables f
 Analyzing function body: f
 Generating body for f
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitStore
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 [regions] for:   %3 = load i32**, i32*** @g, align 8, !dbg !22, !verifier.code !20
   in function: f
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitReturn
 
 Finished analyzing function: f
 
 Analyzing function: malloc
 -------INSERT: Global Variables malloc
 Analyzing function: atexit
 -------INSERT: Global Variables atexit
 Analyzing function: main
 -------INSERT: Global Variables main
 Analyzing function body: main
 Generating body for main
 visitBasicBlock
 visitCall
 smackrep call
 visitCast
 visitCast not vector
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCall
 smackrep call
 visitCall
 smackrep call
 visitBranch
 visitBasicBlock
 visitCall
 smackrep call
 visitUnreachable
 visitBasicBlock
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitLoad
 [regions] for:   %7 = load i32**, i32*** @g, align 8, !dbg !30, !verifier.code !20
   in function: main
 [regions]   using region: <Node:i32*>[0,8]{A}
    found overlap at index 1: <Node:i32*>[0,8]{A}
 [regions]   merged region: <Node:i32*>[0,8]{A}
 [regions]   returning index: 1
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitLoad
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitCast
 visitCast not vector
 visitCall
 smackrep call
 visitReturn
 
 insert initial SH to main
 Finished analyzing function: main
 
 Analyzing function: __SMACK_static_init
 -------INSERT: Global Variables __SMACK_static_init
 Analyzing function body: __SMACK_static_init
 Generating body for __SMACK_static_init
 visitBasicBlock
 visitStore
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 [regions] for: @g = internal global i32** null, align 8, !dbg !0
   at instruction:   store i32** null, i32*** @g
   in function: __SMACK_static_init
 [regions]   using region: <Node:i32**>[0,8]{S}
    found overlap at index 0: <Node:i32**>[0,8]{S}
 [regions]   merged region: <Node:i32**>[0,8]{S}
 [regions]   returning index: 0
 
 visitReturn
 
 Finished analyzing function: __SMACK_static_init
 
 Start Analyzing Prelude: free_g1
 
 Start Analyzing Prelude: free_
 
 Start Analyzing Prelude: free_g2
 
 Start Analyzing Prelude: h
 
 Start Analyzing Prelude: __VERIFIER_nondet_bool
 
 Start Analyzing Prelude: exit
 
 Start Analyzing Prelude: f
 
 Start Analyzing Prelude: malloc
 
 Start Analyzing Prelude: atexit
 
 Start Analyzing Prelude: main
 
 Start Analyzing Prelude: __SMACK_static_init
 
 Start Analyzing Prelude: boogie_si_record_i1
 
 Start Analyzing Prelude: boogie_si_record_ref
 
 Start Analyzing Prelude: $initialize
 
 SMACK generated ../svcomp/memsafety//global-atexit-5.bpl
